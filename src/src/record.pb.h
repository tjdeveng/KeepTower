// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: src/record.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_src_2frecord_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_src_2frecord_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019006 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_src_2frecord_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_src_2frecord_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[9]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_src_2frecord_2eproto;
namespace keeptower {
class AccountGroup;
struct AccountGroupDefaultTypeInternal;
extern AccountGroupDefaultTypeInternal _AccountGroup_default_instance_;
class AccountRecord;
struct AccountRecordDefaultTypeInternal;
extern AccountRecordDefaultTypeInternal _AccountRecord_default_instance_;
class CustomField;
struct CustomFieldDefaultTypeInternal;
extern CustomFieldDefaultTypeInternal _CustomField_default_instance_;
class GroupMembership;
struct GroupMembershipDefaultTypeInternal;
extern GroupMembershipDefaultTypeInternal _GroupMembership_default_instance_;
class TOTPConfig;
struct TOTPConfigDefaultTypeInternal;
extern TOTPConfigDefaultTypeInternal _TOTPConfig_default_instance_;
class VaultData;
struct VaultDataDefaultTypeInternal;
extern VaultDataDefaultTypeInternal _VaultData_default_instance_;
class VaultMetadata;
struct VaultMetadataDefaultTypeInternal;
extern VaultMetadataDefaultTypeInternal _VaultMetadata_default_instance_;
class YubiKeyConfig;
struct YubiKeyConfigDefaultTypeInternal;
extern YubiKeyConfigDefaultTypeInternal _YubiKeyConfig_default_instance_;
class YubiKeyEntry;
struct YubiKeyEntryDefaultTypeInternal;
extern YubiKeyEntryDefaultTypeInternal _YubiKeyEntry_default_instance_;
}  // namespace keeptower
PROTOBUF_NAMESPACE_OPEN
template<> ::keeptower::AccountGroup* Arena::CreateMaybeMessage<::keeptower::AccountGroup>(Arena*);
template<> ::keeptower::AccountRecord* Arena::CreateMaybeMessage<::keeptower::AccountRecord>(Arena*);
template<> ::keeptower::CustomField* Arena::CreateMaybeMessage<::keeptower::CustomField>(Arena*);
template<> ::keeptower::GroupMembership* Arena::CreateMaybeMessage<::keeptower::GroupMembership>(Arena*);
template<> ::keeptower::TOTPConfig* Arena::CreateMaybeMessage<::keeptower::TOTPConfig>(Arena*);
template<> ::keeptower::VaultData* Arena::CreateMaybeMessage<::keeptower::VaultData>(Arena*);
template<> ::keeptower::VaultMetadata* Arena::CreateMaybeMessage<::keeptower::VaultMetadata>(Arena*);
template<> ::keeptower::YubiKeyConfig* Arena::CreateMaybeMessage<::keeptower::YubiKeyConfig>(Arena*);
template<> ::keeptower::YubiKeyEntry* Arena::CreateMaybeMessage<::keeptower::YubiKeyEntry>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace keeptower {

// ===================================================================

class TOTPConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:keeptower.TOTPConfig) */ {
 public:
  inline TOTPConfig() : TOTPConfig(nullptr) {}
  ~TOTPConfig() override;
  explicit constexpr TOTPConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TOTPConfig(const TOTPConfig& from);
  TOTPConfig(TOTPConfig&& from) noexcept
    : TOTPConfig() {
    *this = ::std::move(from);
  }

  inline TOTPConfig& operator=(const TOTPConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline TOTPConfig& operator=(TOTPConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TOTPConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const TOTPConfig* internal_default_instance() {
    return reinterpret_cast<const TOTPConfig*>(
               &_TOTPConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(TOTPConfig& a, TOTPConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(TOTPConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TOTPConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TOTPConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TOTPConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TOTPConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TOTPConfig& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TOTPConfig* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "keeptower.TOTPConfig";
  }
  protected:
  explicit TOTPConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSecretFieldNumber = 1,
    kAlgorithmFieldNumber = 4,
    kIssuerFieldNumber = 5,
    kDigitsFieldNumber = 2,
    kPeriodFieldNumber = 3,
  };
  // string secret = 1;
  void clear_secret();
  const std::string& secret() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_secret(ArgT0&& arg0, ArgT... args);
  std::string* mutable_secret();
  PROTOBUF_NODISCARD std::string* release_secret();
  void set_allocated_secret(std::string* secret);
  private:
  const std::string& _internal_secret() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_secret(const std::string& value);
  std::string* _internal_mutable_secret();
  public:

  // string algorithm = 4;
  void clear_algorithm();
  const std::string& algorithm() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_algorithm(ArgT0&& arg0, ArgT... args);
  std::string* mutable_algorithm();
  PROTOBUF_NODISCARD std::string* release_algorithm();
  void set_allocated_algorithm(std::string* algorithm);
  private:
  const std::string& _internal_algorithm() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_algorithm(const std::string& value);
  std::string* _internal_mutable_algorithm();
  public:

  // string issuer = 5;
  void clear_issuer();
  const std::string& issuer() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_issuer(ArgT0&& arg0, ArgT... args);
  std::string* mutable_issuer();
  PROTOBUF_NODISCARD std::string* release_issuer();
  void set_allocated_issuer(std::string* issuer);
  private:
  const std::string& _internal_issuer() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_issuer(const std::string& value);
  std::string* _internal_mutable_issuer();
  public:

  // int32 digits = 2;
  void clear_digits();
  int32_t digits() const;
  void set_digits(int32_t value);
  private:
  int32_t _internal_digits() const;
  void _internal_set_digits(int32_t value);
  public:

  // int32 period = 3;
  void clear_period();
  int32_t period() const;
  void set_period(int32_t value);
  private:
  int32_t _internal_period() const;
  void _internal_set_period(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:keeptower.TOTPConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr secret_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr algorithm_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr issuer_;
  int32_t digits_;
  int32_t period_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_src_2frecord_2eproto;
};
// -------------------------------------------------------------------

class CustomField final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:keeptower.CustomField) */ {
 public:
  inline CustomField() : CustomField(nullptr) {}
  ~CustomField() override;
  explicit constexpr CustomField(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CustomField(const CustomField& from);
  CustomField(CustomField&& from) noexcept
    : CustomField() {
    *this = ::std::move(from);
  }

  inline CustomField& operator=(const CustomField& from) {
    CopyFrom(from);
    return *this;
  }
  inline CustomField& operator=(CustomField&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CustomField& default_instance() {
    return *internal_default_instance();
  }
  static inline const CustomField* internal_default_instance() {
    return reinterpret_cast<const CustomField*>(
               &_CustomField_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(CustomField& a, CustomField& b) {
    a.Swap(&b);
  }
  inline void Swap(CustomField* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CustomField* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CustomField* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CustomField>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CustomField& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CustomField& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CustomField* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "keeptower.CustomField";
  }
  protected:
  explicit CustomField(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kValueFieldNumber = 2,
    kFieldTypeFieldNumber = 4,
    kIsSensitiveFieldNumber = 3,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string value = 2;
  void clear_value();
  const std::string& value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value();
  PROTOBUF_NODISCARD std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // string field_type = 4;
  void clear_field_type();
  const std::string& field_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_field_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_field_type();
  PROTOBUF_NODISCARD std::string* release_field_type();
  void set_allocated_field_type(std::string* field_type);
  private:
  const std::string& _internal_field_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_field_type(const std::string& value);
  std::string* _internal_mutable_field_type();
  public:

  // bool is_sensitive = 3;
  void clear_is_sensitive();
  bool is_sensitive() const;
  void set_is_sensitive(bool value);
  private:
  bool _internal_is_sensitive() const;
  void _internal_set_is_sensitive(bool value);
  public:

  // @@protoc_insertion_point(class_scope:keeptower.CustomField)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr field_type_;
  bool is_sensitive_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_src_2frecord_2eproto;
};
// -------------------------------------------------------------------

class GroupMembership final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:keeptower.GroupMembership) */ {
 public:
  inline GroupMembership() : GroupMembership(nullptr) {}
  ~GroupMembership() override;
  explicit constexpr GroupMembership(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GroupMembership(const GroupMembership& from);
  GroupMembership(GroupMembership&& from) noexcept
    : GroupMembership() {
    *this = ::std::move(from);
  }

  inline GroupMembership& operator=(const GroupMembership& from) {
    CopyFrom(from);
    return *this;
  }
  inline GroupMembership& operator=(GroupMembership&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GroupMembership& default_instance() {
    return *internal_default_instance();
  }
  static inline const GroupMembership* internal_default_instance() {
    return reinterpret_cast<const GroupMembership*>(
               &_GroupMembership_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(GroupMembership& a, GroupMembership& b) {
    a.Swap(&b);
  }
  inline void Swap(GroupMembership* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GroupMembership* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GroupMembership* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GroupMembership>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GroupMembership& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GroupMembership& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GroupMembership* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "keeptower.GroupMembership";
  }
  protected:
  explicit GroupMembership(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGroupIdFieldNumber = 1,
    kDisplayOrderFieldNumber = 2,
  };
  // string group_id = 1;
  void clear_group_id();
  const std::string& group_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_group_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_group_id();
  PROTOBUF_NODISCARD std::string* release_group_id();
  void set_allocated_group_id(std::string* group_id);
  private:
  const std::string& _internal_group_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_group_id(const std::string& value);
  std::string* _internal_mutable_group_id();
  public:

  // int32 display_order = 2;
  void clear_display_order();
  int32_t display_order() const;
  void set_display_order(int32_t value);
  private:
  int32_t _internal_display_order() const;
  void _internal_set_display_order(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:keeptower.GroupMembership)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr group_id_;
  int32_t display_order_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_src_2frecord_2eproto;
};
// -------------------------------------------------------------------

class AccountGroup final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:keeptower.AccountGroup) */ {
 public:
  inline AccountGroup() : AccountGroup(nullptr) {}
  ~AccountGroup() override;
  explicit constexpr AccountGroup(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AccountGroup(const AccountGroup& from);
  AccountGroup(AccountGroup&& from) noexcept
    : AccountGroup() {
    *this = ::std::move(from);
  }

  inline AccountGroup& operator=(const AccountGroup& from) {
    CopyFrom(from);
    return *this;
  }
  inline AccountGroup& operator=(AccountGroup&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AccountGroup& default_instance() {
    return *internal_default_instance();
  }
  static inline const AccountGroup* internal_default_instance() {
    return reinterpret_cast<const AccountGroup*>(
               &_AccountGroup_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(AccountGroup& a, AccountGroup& b) {
    a.Swap(&b);
  }
  inline void Swap(AccountGroup* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AccountGroup* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AccountGroup* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AccountGroup>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AccountGroup& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AccountGroup& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AccountGroup* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "keeptower.AccountGroup";
  }
  protected:
  explicit AccountGroup(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGroupIdFieldNumber = 1,
    kGroupNameFieldNumber = 2,
    kDescriptionFieldNumber = 6,
    kColorFieldNumber = 7,
    kIconFieldNumber = 8,
    kDisplayOrderFieldNumber = 3,
    kIsExpandedFieldNumber = 4,
    kIsSystemGroupFieldNumber = 5,
  };
  // string group_id = 1;
  void clear_group_id();
  const std::string& group_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_group_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_group_id();
  PROTOBUF_NODISCARD std::string* release_group_id();
  void set_allocated_group_id(std::string* group_id);
  private:
  const std::string& _internal_group_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_group_id(const std::string& value);
  std::string* _internal_mutable_group_id();
  public:

  // string group_name = 2;
  void clear_group_name();
  const std::string& group_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_group_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_group_name();
  PROTOBUF_NODISCARD std::string* release_group_name();
  void set_allocated_group_name(std::string* group_name);
  private:
  const std::string& _internal_group_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_group_name(const std::string& value);
  std::string* _internal_mutable_group_name();
  public:

  // string description = 6;
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // string color = 7;
  void clear_color();
  const std::string& color() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_color(ArgT0&& arg0, ArgT... args);
  std::string* mutable_color();
  PROTOBUF_NODISCARD std::string* release_color();
  void set_allocated_color(std::string* color);
  private:
  const std::string& _internal_color() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_color(const std::string& value);
  std::string* _internal_mutable_color();
  public:

  // string icon = 8;
  void clear_icon();
  const std::string& icon() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_icon(ArgT0&& arg0, ArgT... args);
  std::string* mutable_icon();
  PROTOBUF_NODISCARD std::string* release_icon();
  void set_allocated_icon(std::string* icon);
  private:
  const std::string& _internal_icon() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_icon(const std::string& value);
  std::string* _internal_mutable_icon();
  public:

  // int32 display_order = 3;
  void clear_display_order();
  int32_t display_order() const;
  void set_display_order(int32_t value);
  private:
  int32_t _internal_display_order() const;
  void _internal_set_display_order(int32_t value);
  public:

  // bool is_expanded = 4;
  void clear_is_expanded();
  bool is_expanded() const;
  void set_is_expanded(bool value);
  private:
  bool _internal_is_expanded() const;
  void _internal_set_is_expanded(bool value);
  public:

  // bool is_system_group = 5;
  void clear_is_system_group();
  bool is_system_group() const;
  void set_is_system_group(bool value);
  private:
  bool _internal_is_system_group() const;
  void _internal_set_is_system_group(bool value);
  public:

  // @@protoc_insertion_point(class_scope:keeptower.AccountGroup)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr group_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr group_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr color_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr icon_;
  int32_t display_order_;
  bool is_expanded_;
  bool is_system_group_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_src_2frecord_2eproto;
};
// -------------------------------------------------------------------

class AccountRecord final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:keeptower.AccountRecord) */ {
 public:
  inline AccountRecord() : AccountRecord(nullptr) {}
  ~AccountRecord() override;
  explicit constexpr AccountRecord(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AccountRecord(const AccountRecord& from);
  AccountRecord(AccountRecord&& from) noexcept
    : AccountRecord() {
    *this = ::std::move(from);
  }

  inline AccountRecord& operator=(const AccountRecord& from) {
    CopyFrom(from);
    return *this;
  }
  inline AccountRecord& operator=(AccountRecord&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AccountRecord& default_instance() {
    return *internal_default_instance();
  }
  static inline const AccountRecord* internal_default_instance() {
    return reinterpret_cast<const AccountRecord*>(
               &_AccountRecord_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(AccountRecord& a, AccountRecord& b) {
    a.Swap(&b);
  }
  inline void Swap(AccountRecord* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AccountRecord* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AccountRecord* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AccountRecord>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AccountRecord& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AccountRecord& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AccountRecord* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "keeptower.AccountRecord";
  }
  protected:
  explicit AccountRecord(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTagsFieldNumber = 20,
    kCustomFieldsFieldNumber = 33,
    kSecurityQuestionsFieldNumber = 34,
    kPasswordHistoryFieldNumber = 35,
    kGroupsFieldNumber = 38,
    kIdFieldNumber = 1,
    kAccountNameFieldNumber = 2,
    kUserNameFieldNumber = 3,
    kPasswordFieldNumber = 4,
    kEmailFieldNumber = 5,
    kWebsiteFieldNumber = 6,
    kNotesFieldNumber = 19,
    kColorFieldNumber = 23,
    kIconFieldNumber = 24,
    kRecoveryEmailFieldNumber = 36,
    kRecoveryPhoneFieldNumber = 37,
    kTotpFieldNumber = 32,
    kCreatedAtFieldNumber = 16,
    kModifiedAtFieldNumber = 17,
    kPasswordChangedAtFieldNumber = 18,
    kIsFavoriteFieldNumber = 21,
    kIsArchivedFieldNumber = 22,
    kIsAdminOnlyViewableFieldNumber = 26,
    kIsAdminOnlyDeletableFieldNumber = 27,
    kGlobalDisplayOrderFieldNumber = 25,
  };
  // repeated string tags = 20;
  int tags_size() const;
  private:
  int _internal_tags_size() const;
  public:
  void clear_tags();
  const std::string& tags(int index) const;
  std::string* mutable_tags(int index);
  void set_tags(int index, const std::string& value);
  void set_tags(int index, std::string&& value);
  void set_tags(int index, const char* value);
  void set_tags(int index, const char* value, size_t size);
  std::string* add_tags();
  void add_tags(const std::string& value);
  void add_tags(std::string&& value);
  void add_tags(const char* value);
  void add_tags(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& tags() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_tags();
  private:
  const std::string& _internal_tags(int index) const;
  std::string* _internal_add_tags();
  public:

  // repeated .keeptower.CustomField custom_fields = 33;
  int custom_fields_size() const;
  private:
  int _internal_custom_fields_size() const;
  public:
  void clear_custom_fields();
  ::keeptower::CustomField* mutable_custom_fields(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::keeptower::CustomField >*
      mutable_custom_fields();
  private:
  const ::keeptower::CustomField& _internal_custom_fields(int index) const;
  ::keeptower::CustomField* _internal_add_custom_fields();
  public:
  const ::keeptower::CustomField& custom_fields(int index) const;
  ::keeptower::CustomField* add_custom_fields();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::keeptower::CustomField >&
      custom_fields() const;

  // repeated .keeptower.CustomField security_questions = 34;
  int security_questions_size() const;
  private:
  int _internal_security_questions_size() const;
  public:
  void clear_security_questions();
  ::keeptower::CustomField* mutable_security_questions(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::keeptower::CustomField >*
      mutable_security_questions();
  private:
  const ::keeptower::CustomField& _internal_security_questions(int index) const;
  ::keeptower::CustomField* _internal_add_security_questions();
  public:
  const ::keeptower::CustomField& security_questions(int index) const;
  ::keeptower::CustomField* add_security_questions();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::keeptower::CustomField >&
      security_questions() const;

  // repeated string password_history = 35;
  int password_history_size() const;
  private:
  int _internal_password_history_size() const;
  public:
  void clear_password_history();
  const std::string& password_history(int index) const;
  std::string* mutable_password_history(int index);
  void set_password_history(int index, const std::string& value);
  void set_password_history(int index, std::string&& value);
  void set_password_history(int index, const char* value);
  void set_password_history(int index, const char* value, size_t size);
  std::string* add_password_history();
  void add_password_history(const std::string& value);
  void add_password_history(std::string&& value);
  void add_password_history(const char* value);
  void add_password_history(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& password_history() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_password_history();
  private:
  const std::string& _internal_password_history(int index) const;
  std::string* _internal_add_password_history();
  public:

  // repeated .keeptower.GroupMembership groups = 38;
  int groups_size() const;
  private:
  int _internal_groups_size() const;
  public:
  void clear_groups();
  ::keeptower::GroupMembership* mutable_groups(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::keeptower::GroupMembership >*
      mutable_groups();
  private:
  const ::keeptower::GroupMembership& _internal_groups(int index) const;
  ::keeptower::GroupMembership* _internal_add_groups();
  public:
  const ::keeptower::GroupMembership& groups(int index) const;
  ::keeptower::GroupMembership* add_groups();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::keeptower::GroupMembership >&
      groups() const;

  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string account_name = 2;
  void clear_account_name();
  const std::string& account_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_account_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_account_name();
  PROTOBUF_NODISCARD std::string* release_account_name();
  void set_allocated_account_name(std::string* account_name);
  private:
  const std::string& _internal_account_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_account_name(const std::string& value);
  std::string* _internal_mutable_account_name();
  public:

  // string user_name = 3;
  void clear_user_name();
  const std::string& user_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_name();
  PROTOBUF_NODISCARD std::string* release_user_name();
  void set_allocated_user_name(std::string* user_name);
  private:
  const std::string& _internal_user_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_name(const std::string& value);
  std::string* _internal_mutable_user_name();
  public:

  // string password = 4;
  void clear_password();
  const std::string& password() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_password(ArgT0&& arg0, ArgT... args);
  std::string* mutable_password();
  PROTOBUF_NODISCARD std::string* release_password();
  void set_allocated_password(std::string* password);
  private:
  const std::string& _internal_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_password(const std::string& value);
  std::string* _internal_mutable_password();
  public:

  // string email = 5;
  void clear_email();
  const std::string& email() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_email(ArgT0&& arg0, ArgT... args);
  std::string* mutable_email();
  PROTOBUF_NODISCARD std::string* release_email();
  void set_allocated_email(std::string* email);
  private:
  const std::string& _internal_email() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_email(const std::string& value);
  std::string* _internal_mutable_email();
  public:

  // string website = 6;
  void clear_website();
  const std::string& website() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_website(ArgT0&& arg0, ArgT... args);
  std::string* mutable_website();
  PROTOBUF_NODISCARD std::string* release_website();
  void set_allocated_website(std::string* website);
  private:
  const std::string& _internal_website() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_website(const std::string& value);
  std::string* _internal_mutable_website();
  public:

  // string notes = 19;
  void clear_notes();
  const std::string& notes() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_notes(ArgT0&& arg0, ArgT... args);
  std::string* mutable_notes();
  PROTOBUF_NODISCARD std::string* release_notes();
  void set_allocated_notes(std::string* notes);
  private:
  const std::string& _internal_notes() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_notes(const std::string& value);
  std::string* _internal_mutable_notes();
  public:

  // string color = 23;
  void clear_color();
  const std::string& color() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_color(ArgT0&& arg0, ArgT... args);
  std::string* mutable_color();
  PROTOBUF_NODISCARD std::string* release_color();
  void set_allocated_color(std::string* color);
  private:
  const std::string& _internal_color() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_color(const std::string& value);
  std::string* _internal_mutable_color();
  public:

  // string icon = 24;
  void clear_icon();
  const std::string& icon() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_icon(ArgT0&& arg0, ArgT... args);
  std::string* mutable_icon();
  PROTOBUF_NODISCARD std::string* release_icon();
  void set_allocated_icon(std::string* icon);
  private:
  const std::string& _internal_icon() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_icon(const std::string& value);
  std::string* _internal_mutable_icon();
  public:

  // string recovery_email = 36;
  void clear_recovery_email();
  const std::string& recovery_email() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_recovery_email(ArgT0&& arg0, ArgT... args);
  std::string* mutable_recovery_email();
  PROTOBUF_NODISCARD std::string* release_recovery_email();
  void set_allocated_recovery_email(std::string* recovery_email);
  private:
  const std::string& _internal_recovery_email() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_recovery_email(const std::string& value);
  std::string* _internal_mutable_recovery_email();
  public:

  // string recovery_phone = 37;
  void clear_recovery_phone();
  const std::string& recovery_phone() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_recovery_phone(ArgT0&& arg0, ArgT... args);
  std::string* mutable_recovery_phone();
  PROTOBUF_NODISCARD std::string* release_recovery_phone();
  void set_allocated_recovery_phone(std::string* recovery_phone);
  private:
  const std::string& _internal_recovery_phone() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_recovery_phone(const std::string& value);
  std::string* _internal_mutable_recovery_phone();
  public:

  // .keeptower.TOTPConfig totp = 32;
  bool has_totp() const;
  private:
  bool _internal_has_totp() const;
  public:
  void clear_totp();
  const ::keeptower::TOTPConfig& totp() const;
  PROTOBUF_NODISCARD ::keeptower::TOTPConfig* release_totp();
  ::keeptower::TOTPConfig* mutable_totp();
  void set_allocated_totp(::keeptower::TOTPConfig* totp);
  private:
  const ::keeptower::TOTPConfig& _internal_totp() const;
  ::keeptower::TOTPConfig* _internal_mutable_totp();
  public:
  void unsafe_arena_set_allocated_totp(
      ::keeptower::TOTPConfig* totp);
  ::keeptower::TOTPConfig* unsafe_arena_release_totp();

  // int64 created_at = 16;
  void clear_created_at();
  int64_t created_at() const;
  void set_created_at(int64_t value);
  private:
  int64_t _internal_created_at() const;
  void _internal_set_created_at(int64_t value);
  public:

  // int64 modified_at = 17;
  void clear_modified_at();
  int64_t modified_at() const;
  void set_modified_at(int64_t value);
  private:
  int64_t _internal_modified_at() const;
  void _internal_set_modified_at(int64_t value);
  public:

  // int64 password_changed_at = 18;
  void clear_password_changed_at();
  int64_t password_changed_at() const;
  void set_password_changed_at(int64_t value);
  private:
  int64_t _internal_password_changed_at() const;
  void _internal_set_password_changed_at(int64_t value);
  public:

  // bool is_favorite = 21;
  void clear_is_favorite();
  bool is_favorite() const;
  void set_is_favorite(bool value);
  private:
  bool _internal_is_favorite() const;
  void _internal_set_is_favorite(bool value);
  public:

  // bool is_archived = 22;
  void clear_is_archived();
  bool is_archived() const;
  void set_is_archived(bool value);
  private:
  bool _internal_is_archived() const;
  void _internal_set_is_archived(bool value);
  public:

  // bool is_admin_only_viewable = 26;
  void clear_is_admin_only_viewable();
  bool is_admin_only_viewable() const;
  void set_is_admin_only_viewable(bool value);
  private:
  bool _internal_is_admin_only_viewable() const;
  void _internal_set_is_admin_only_viewable(bool value);
  public:

  // bool is_admin_only_deletable = 27;
  void clear_is_admin_only_deletable();
  bool is_admin_only_deletable() const;
  void set_is_admin_only_deletable(bool value);
  private:
  bool _internal_is_admin_only_deletable() const;
  void _internal_set_is_admin_only_deletable(bool value);
  public:

  // int32 global_display_order = 25;
  void clear_global_display_order();
  int32_t global_display_order() const;
  void set_global_display_order(int32_t value);
  private:
  int32_t _internal_global_display_order() const;
  void _internal_set_global_display_order(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:keeptower.AccountRecord)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> tags_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::keeptower::CustomField > custom_fields_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::keeptower::CustomField > security_questions_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> password_history_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::keeptower::GroupMembership > groups_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr account_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr password_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr email_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr website_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr notes_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr color_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr icon_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr recovery_email_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr recovery_phone_;
  ::keeptower::TOTPConfig* totp_;
  int64_t created_at_;
  int64_t modified_at_;
  int64_t password_changed_at_;
  bool is_favorite_;
  bool is_archived_;
  bool is_admin_only_viewable_;
  bool is_admin_only_deletable_;
  int32_t global_display_order_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_src_2frecord_2eproto;
};
// -------------------------------------------------------------------

class VaultMetadata final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:keeptower.VaultMetadata) */ {
 public:
  inline VaultMetadata() : VaultMetadata(nullptr) {}
  ~VaultMetadata() override;
  explicit constexpr VaultMetadata(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VaultMetadata(const VaultMetadata& from);
  VaultMetadata(VaultMetadata&& from) noexcept
    : VaultMetadata() {
    *this = ::std::move(from);
  }

  inline VaultMetadata& operator=(const VaultMetadata& from) {
    CopyFrom(from);
    return *this;
  }
  inline VaultMetadata& operator=(VaultMetadata&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VaultMetadata& default_instance() {
    return *internal_default_instance();
  }
  static inline const VaultMetadata* internal_default_instance() {
    return reinterpret_cast<const VaultMetadata*>(
               &_VaultMetadata_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(VaultMetadata& a, VaultMetadata& b) {
    a.Swap(&b);
  }
  inline void Swap(VaultMetadata* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VaultMetadata* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VaultMetadata* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VaultMetadata>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VaultMetadata& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const VaultMetadata& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VaultMetadata* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "keeptower.VaultMetadata";
  }
  protected:
  explicit VaultMetadata(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 5,
    kDescriptionFieldNumber = 6,
    kCreatedAtFieldNumber = 2,
    kLastModifiedFieldNumber = 3,
    kLastAccessedFieldNumber = 4,
    kAccessCountFieldNumber = 7,
    kSchemaVersionFieldNumber = 1,
  };
  // string name = 5;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string description = 6;
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // int64 created_at = 2;
  void clear_created_at();
  int64_t created_at() const;
  void set_created_at(int64_t value);
  private:
  int64_t _internal_created_at() const;
  void _internal_set_created_at(int64_t value);
  public:

  // int64 last_modified = 3;
  void clear_last_modified();
  int64_t last_modified() const;
  void set_last_modified(int64_t value);
  private:
  int64_t _internal_last_modified() const;
  void _internal_set_last_modified(int64_t value);
  public:

  // int64 last_accessed = 4;
  void clear_last_accessed();
  int64_t last_accessed() const;
  void set_last_accessed(int64_t value);
  private:
  int64_t _internal_last_accessed() const;
  void _internal_set_last_accessed(int64_t value);
  public:

  // int64 access_count = 7;
  void clear_access_count();
  int64_t access_count() const;
  void set_access_count(int64_t value);
  private:
  int64_t _internal_access_count() const;
  void _internal_set_access_count(int64_t value);
  public:

  // int32 schema_version = 1;
  void clear_schema_version();
  int32_t schema_version() const;
  void set_schema_version(int32_t value);
  private:
  int32_t _internal_schema_version() const;
  void _internal_set_schema_version(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:keeptower.VaultMetadata)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
  int64_t created_at_;
  int64_t last_modified_;
  int64_t last_accessed_;
  int64_t access_count_;
  int32_t schema_version_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_src_2frecord_2eproto;
};
// -------------------------------------------------------------------

class YubiKeyEntry final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:keeptower.YubiKeyEntry) */ {
 public:
  inline YubiKeyEntry() : YubiKeyEntry(nullptr) {}
  ~YubiKeyEntry() override;
  explicit constexpr YubiKeyEntry(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  YubiKeyEntry(const YubiKeyEntry& from);
  YubiKeyEntry(YubiKeyEntry&& from) noexcept
    : YubiKeyEntry() {
    *this = ::std::move(from);
  }

  inline YubiKeyEntry& operator=(const YubiKeyEntry& from) {
    CopyFrom(from);
    return *this;
  }
  inline YubiKeyEntry& operator=(YubiKeyEntry&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const YubiKeyEntry& default_instance() {
    return *internal_default_instance();
  }
  static inline const YubiKeyEntry* internal_default_instance() {
    return reinterpret_cast<const YubiKeyEntry*>(
               &_YubiKeyEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(YubiKeyEntry& a, YubiKeyEntry& b) {
    a.Swap(&b);
  }
  inline void Swap(YubiKeyEntry* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(YubiKeyEntry* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  YubiKeyEntry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<YubiKeyEntry>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const YubiKeyEntry& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const YubiKeyEntry& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(YubiKeyEntry* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "keeptower.YubiKeyEntry";
  }
  protected:
  explicit YubiKeyEntry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSerialFieldNumber = 1,
    kNameFieldNumber = 2,
    kAddedAtFieldNumber = 3,
  };
  // string serial = 1;
  void clear_serial();
  const std::string& serial() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_serial(ArgT0&& arg0, ArgT... args);
  std::string* mutable_serial();
  PROTOBUF_NODISCARD std::string* release_serial();
  void set_allocated_serial(std::string* serial);
  private:
  const std::string& _internal_serial() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_serial(const std::string& value);
  std::string* _internal_mutable_serial();
  public:

  // string name = 2;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // int64 added_at = 3;
  void clear_added_at();
  int64_t added_at() const;
  void set_added_at(int64_t value);
  private:
  int64_t _internal_added_at() const;
  void _internal_set_added_at(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:keeptower.YubiKeyEntry)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr serial_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  int64_t added_at_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_src_2frecord_2eproto;
};
// -------------------------------------------------------------------

class YubiKeyConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:keeptower.YubiKeyConfig) */ {
 public:
  inline YubiKeyConfig() : YubiKeyConfig(nullptr) {}
  ~YubiKeyConfig() override;
  explicit constexpr YubiKeyConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  YubiKeyConfig(const YubiKeyConfig& from);
  YubiKeyConfig(YubiKeyConfig&& from) noexcept
    : YubiKeyConfig() {
    *this = ::std::move(from);
  }

  inline YubiKeyConfig& operator=(const YubiKeyConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline YubiKeyConfig& operator=(YubiKeyConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const YubiKeyConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const YubiKeyConfig* internal_default_instance() {
    return reinterpret_cast<const YubiKeyConfig*>(
               &_YubiKeyConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(YubiKeyConfig& a, YubiKeyConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(YubiKeyConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(YubiKeyConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  YubiKeyConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<YubiKeyConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const YubiKeyConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const YubiKeyConfig& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(YubiKeyConfig* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "keeptower.YubiKeyConfig";
  }
  protected:
  explicit YubiKeyConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kYubikeyEntriesFieldNumber = 5,
    kSerialFieldNumber = 1,
    kChallengeFieldNumber = 2,
    kConfiguredAtFieldNumber = 3,
    kRequiredFieldNumber = 4,
  };
  // repeated .keeptower.YubiKeyEntry yubikey_entries = 5;
  int yubikey_entries_size() const;
  private:
  int _internal_yubikey_entries_size() const;
  public:
  void clear_yubikey_entries();
  ::keeptower::YubiKeyEntry* mutable_yubikey_entries(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::keeptower::YubiKeyEntry >*
      mutable_yubikey_entries();
  private:
  const ::keeptower::YubiKeyEntry& _internal_yubikey_entries(int index) const;
  ::keeptower::YubiKeyEntry* _internal_add_yubikey_entries();
  public:
  const ::keeptower::YubiKeyEntry& yubikey_entries(int index) const;
  ::keeptower::YubiKeyEntry* add_yubikey_entries();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::keeptower::YubiKeyEntry >&
      yubikey_entries() const;

  // string serial = 1 [deprecated = true];
  PROTOBUF_DEPRECATED void clear_serial();
  PROTOBUF_DEPRECATED const std::string& serial() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  PROTOBUF_DEPRECATED void set_serial(ArgT0&& arg0, ArgT... args);
  PROTOBUF_DEPRECATED std::string* mutable_serial();
  PROTOBUF_NODISCARD PROTOBUF_DEPRECATED std::string* release_serial();
  PROTOBUF_DEPRECATED void set_allocated_serial(std::string* serial);
  private:
  const std::string& _internal_serial() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_serial(const std::string& value);
  std::string* _internal_mutable_serial();
  public:

  // bytes challenge = 2;
  void clear_challenge();
  const std::string& challenge() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_challenge(ArgT0&& arg0, ArgT... args);
  std::string* mutable_challenge();
  PROTOBUF_NODISCARD std::string* release_challenge();
  void set_allocated_challenge(std::string* challenge);
  private:
  const std::string& _internal_challenge() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_challenge(const std::string& value);
  std::string* _internal_mutable_challenge();
  public:

  // int64 configured_at = 3;
  void clear_configured_at();
  int64_t configured_at() const;
  void set_configured_at(int64_t value);
  private:
  int64_t _internal_configured_at() const;
  void _internal_set_configured_at(int64_t value);
  public:

  // bool required = 4;
  void clear_required();
  bool required() const;
  void set_required(bool value);
  private:
  bool _internal_required() const;
  void _internal_set_required(bool value);
  public:

  // @@protoc_insertion_point(class_scope:keeptower.YubiKeyConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::keeptower::YubiKeyEntry > yubikey_entries_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr serial_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr challenge_;
  int64_t configured_at_;
  bool required_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_src_2frecord_2eproto;
};
// -------------------------------------------------------------------

class VaultData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:keeptower.VaultData) */ {
 public:
  inline VaultData() : VaultData(nullptr) {}
  ~VaultData() override;
  explicit constexpr VaultData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VaultData(const VaultData& from);
  VaultData(VaultData&& from) noexcept
    : VaultData() {
    *this = ::std::move(from);
  }

  inline VaultData& operator=(const VaultData& from) {
    CopyFrom(from);
    return *this;
  }
  inline VaultData& operator=(VaultData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VaultData& default_instance() {
    return *internal_default_instance();
  }
  static inline const VaultData* internal_default_instance() {
    return reinterpret_cast<const VaultData*>(
               &_VaultData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(VaultData& a, VaultData& b) {
    a.Swap(&b);
  }
  inline void Swap(VaultData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VaultData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VaultData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VaultData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VaultData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const VaultData& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VaultData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "keeptower.VaultData";
  }
  protected:
  explicit VaultData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAccountsFieldNumber = 1,
    kGroupsFieldNumber = 32,
    kMetadataFieldNumber = 2,
    kYubikeyConfigFieldNumber = 16,
    kFecEnabledFieldNumber = 17,
    kFecRedundancyPercentFieldNumber = 18,
  };
  // repeated .keeptower.AccountRecord accounts = 1;
  int accounts_size() const;
  private:
  int _internal_accounts_size() const;
  public:
  void clear_accounts();
  ::keeptower::AccountRecord* mutable_accounts(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::keeptower::AccountRecord >*
      mutable_accounts();
  private:
  const ::keeptower::AccountRecord& _internal_accounts(int index) const;
  ::keeptower::AccountRecord* _internal_add_accounts();
  public:
  const ::keeptower::AccountRecord& accounts(int index) const;
  ::keeptower::AccountRecord* add_accounts();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::keeptower::AccountRecord >&
      accounts() const;

  // repeated .keeptower.AccountGroup groups = 32;
  int groups_size() const;
  private:
  int _internal_groups_size() const;
  public:
  void clear_groups();
  ::keeptower::AccountGroup* mutable_groups(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::keeptower::AccountGroup >*
      mutable_groups();
  private:
  const ::keeptower::AccountGroup& _internal_groups(int index) const;
  ::keeptower::AccountGroup* _internal_add_groups();
  public:
  const ::keeptower::AccountGroup& groups(int index) const;
  ::keeptower::AccountGroup* add_groups();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::keeptower::AccountGroup >&
      groups() const;

  // .keeptower.VaultMetadata metadata = 2;
  bool has_metadata() const;
  private:
  bool _internal_has_metadata() const;
  public:
  void clear_metadata();
  const ::keeptower::VaultMetadata& metadata() const;
  PROTOBUF_NODISCARD ::keeptower::VaultMetadata* release_metadata();
  ::keeptower::VaultMetadata* mutable_metadata();
  void set_allocated_metadata(::keeptower::VaultMetadata* metadata);
  private:
  const ::keeptower::VaultMetadata& _internal_metadata() const;
  ::keeptower::VaultMetadata* _internal_mutable_metadata();
  public:
  void unsafe_arena_set_allocated_metadata(
      ::keeptower::VaultMetadata* metadata);
  ::keeptower::VaultMetadata* unsafe_arena_release_metadata();

  // .keeptower.YubiKeyConfig yubikey_config = 16;
  bool has_yubikey_config() const;
  private:
  bool _internal_has_yubikey_config() const;
  public:
  void clear_yubikey_config();
  const ::keeptower::YubiKeyConfig& yubikey_config() const;
  PROTOBUF_NODISCARD ::keeptower::YubiKeyConfig* release_yubikey_config();
  ::keeptower::YubiKeyConfig* mutable_yubikey_config();
  void set_allocated_yubikey_config(::keeptower::YubiKeyConfig* yubikey_config);
  private:
  const ::keeptower::YubiKeyConfig& _internal_yubikey_config() const;
  ::keeptower::YubiKeyConfig* _internal_mutable_yubikey_config();
  public:
  void unsafe_arena_set_allocated_yubikey_config(
      ::keeptower::YubiKeyConfig* yubikey_config);
  ::keeptower::YubiKeyConfig* unsafe_arena_release_yubikey_config();

  // bool fec_enabled = 17;
  void clear_fec_enabled();
  bool fec_enabled() const;
  void set_fec_enabled(bool value);
  private:
  bool _internal_fec_enabled() const;
  void _internal_set_fec_enabled(bool value);
  public:

  // int32 fec_redundancy_percent = 18;
  void clear_fec_redundancy_percent();
  int32_t fec_redundancy_percent() const;
  void set_fec_redundancy_percent(int32_t value);
  private:
  int32_t _internal_fec_redundancy_percent() const;
  void _internal_set_fec_redundancy_percent(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:keeptower.VaultData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::keeptower::AccountRecord > accounts_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::keeptower::AccountGroup > groups_;
  ::keeptower::VaultMetadata* metadata_;
  ::keeptower::YubiKeyConfig* yubikey_config_;
  bool fec_enabled_;
  int32_t fec_redundancy_percent_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_src_2frecord_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// TOTPConfig

// string secret = 1;
inline void TOTPConfig::clear_secret() {
  secret_.ClearToEmpty();
}
inline const std::string& TOTPConfig::secret() const {
  // @@protoc_insertion_point(field_get:keeptower.TOTPConfig.secret)
  return _internal_secret();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TOTPConfig::set_secret(ArgT0&& arg0, ArgT... args) {
 
 secret_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:keeptower.TOTPConfig.secret)
}
inline std::string* TOTPConfig::mutable_secret() {
  std::string* _s = _internal_mutable_secret();
  // @@protoc_insertion_point(field_mutable:keeptower.TOTPConfig.secret)
  return _s;
}
inline const std::string& TOTPConfig::_internal_secret() const {
  return secret_.Get();
}
inline void TOTPConfig::_internal_set_secret(const std::string& value) {
  
  secret_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TOTPConfig::_internal_mutable_secret() {
  
  return secret_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TOTPConfig::release_secret() {
  // @@protoc_insertion_point(field_release:keeptower.TOTPConfig.secret)
  return secret_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TOTPConfig::set_allocated_secret(std::string* secret) {
  if (secret != nullptr) {
    
  } else {
    
  }
  secret_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), secret,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (secret_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    secret_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:keeptower.TOTPConfig.secret)
}

// int32 digits = 2;
inline void TOTPConfig::clear_digits() {
  digits_ = 0;
}
inline int32_t TOTPConfig::_internal_digits() const {
  return digits_;
}
inline int32_t TOTPConfig::digits() const {
  // @@protoc_insertion_point(field_get:keeptower.TOTPConfig.digits)
  return _internal_digits();
}
inline void TOTPConfig::_internal_set_digits(int32_t value) {
  
  digits_ = value;
}
inline void TOTPConfig::set_digits(int32_t value) {
  _internal_set_digits(value);
  // @@protoc_insertion_point(field_set:keeptower.TOTPConfig.digits)
}

// int32 period = 3;
inline void TOTPConfig::clear_period() {
  period_ = 0;
}
inline int32_t TOTPConfig::_internal_period() const {
  return period_;
}
inline int32_t TOTPConfig::period() const {
  // @@protoc_insertion_point(field_get:keeptower.TOTPConfig.period)
  return _internal_period();
}
inline void TOTPConfig::_internal_set_period(int32_t value) {
  
  period_ = value;
}
inline void TOTPConfig::set_period(int32_t value) {
  _internal_set_period(value);
  // @@protoc_insertion_point(field_set:keeptower.TOTPConfig.period)
}

// string algorithm = 4;
inline void TOTPConfig::clear_algorithm() {
  algorithm_.ClearToEmpty();
}
inline const std::string& TOTPConfig::algorithm() const {
  // @@protoc_insertion_point(field_get:keeptower.TOTPConfig.algorithm)
  return _internal_algorithm();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TOTPConfig::set_algorithm(ArgT0&& arg0, ArgT... args) {
 
 algorithm_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:keeptower.TOTPConfig.algorithm)
}
inline std::string* TOTPConfig::mutable_algorithm() {
  std::string* _s = _internal_mutable_algorithm();
  // @@protoc_insertion_point(field_mutable:keeptower.TOTPConfig.algorithm)
  return _s;
}
inline const std::string& TOTPConfig::_internal_algorithm() const {
  return algorithm_.Get();
}
inline void TOTPConfig::_internal_set_algorithm(const std::string& value) {
  
  algorithm_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TOTPConfig::_internal_mutable_algorithm() {
  
  return algorithm_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TOTPConfig::release_algorithm() {
  // @@protoc_insertion_point(field_release:keeptower.TOTPConfig.algorithm)
  return algorithm_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TOTPConfig::set_allocated_algorithm(std::string* algorithm) {
  if (algorithm != nullptr) {
    
  } else {
    
  }
  algorithm_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), algorithm,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (algorithm_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    algorithm_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:keeptower.TOTPConfig.algorithm)
}

// string issuer = 5;
inline void TOTPConfig::clear_issuer() {
  issuer_.ClearToEmpty();
}
inline const std::string& TOTPConfig::issuer() const {
  // @@protoc_insertion_point(field_get:keeptower.TOTPConfig.issuer)
  return _internal_issuer();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TOTPConfig::set_issuer(ArgT0&& arg0, ArgT... args) {
 
 issuer_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:keeptower.TOTPConfig.issuer)
}
inline std::string* TOTPConfig::mutable_issuer() {
  std::string* _s = _internal_mutable_issuer();
  // @@protoc_insertion_point(field_mutable:keeptower.TOTPConfig.issuer)
  return _s;
}
inline const std::string& TOTPConfig::_internal_issuer() const {
  return issuer_.Get();
}
inline void TOTPConfig::_internal_set_issuer(const std::string& value) {
  
  issuer_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TOTPConfig::_internal_mutable_issuer() {
  
  return issuer_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TOTPConfig::release_issuer() {
  // @@protoc_insertion_point(field_release:keeptower.TOTPConfig.issuer)
  return issuer_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TOTPConfig::set_allocated_issuer(std::string* issuer) {
  if (issuer != nullptr) {
    
  } else {
    
  }
  issuer_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), issuer,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (issuer_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    issuer_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:keeptower.TOTPConfig.issuer)
}

// -------------------------------------------------------------------

// CustomField

// string name = 1;
inline void CustomField::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& CustomField::name() const {
  // @@protoc_insertion_point(field_get:keeptower.CustomField.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CustomField::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:keeptower.CustomField.name)
}
inline std::string* CustomField::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:keeptower.CustomField.name)
  return _s;
}
inline const std::string& CustomField::_internal_name() const {
  return name_.Get();
}
inline void CustomField::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CustomField::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CustomField::release_name() {
  // @@protoc_insertion_point(field_release:keeptower.CustomField.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CustomField::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:keeptower.CustomField.name)
}

// string value = 2;
inline void CustomField::clear_value() {
  value_.ClearToEmpty();
}
inline const std::string& CustomField::value() const {
  // @@protoc_insertion_point(field_get:keeptower.CustomField.value)
  return _internal_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CustomField::set_value(ArgT0&& arg0, ArgT... args) {
 
 value_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:keeptower.CustomField.value)
}
inline std::string* CustomField::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:keeptower.CustomField.value)
  return _s;
}
inline const std::string& CustomField::_internal_value() const {
  return value_.Get();
}
inline void CustomField::_internal_set_value(const std::string& value) {
  
  value_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CustomField::_internal_mutable_value() {
  
  return value_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CustomField::release_value() {
  // @@protoc_insertion_point(field_release:keeptower.CustomField.value)
  return value_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CustomField::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (value_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:keeptower.CustomField.value)
}

// bool is_sensitive = 3;
inline void CustomField::clear_is_sensitive() {
  is_sensitive_ = false;
}
inline bool CustomField::_internal_is_sensitive() const {
  return is_sensitive_;
}
inline bool CustomField::is_sensitive() const {
  // @@protoc_insertion_point(field_get:keeptower.CustomField.is_sensitive)
  return _internal_is_sensitive();
}
inline void CustomField::_internal_set_is_sensitive(bool value) {
  
  is_sensitive_ = value;
}
inline void CustomField::set_is_sensitive(bool value) {
  _internal_set_is_sensitive(value);
  // @@protoc_insertion_point(field_set:keeptower.CustomField.is_sensitive)
}

// string field_type = 4;
inline void CustomField::clear_field_type() {
  field_type_.ClearToEmpty();
}
inline const std::string& CustomField::field_type() const {
  // @@protoc_insertion_point(field_get:keeptower.CustomField.field_type)
  return _internal_field_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CustomField::set_field_type(ArgT0&& arg0, ArgT... args) {
 
 field_type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:keeptower.CustomField.field_type)
}
inline std::string* CustomField::mutable_field_type() {
  std::string* _s = _internal_mutable_field_type();
  // @@protoc_insertion_point(field_mutable:keeptower.CustomField.field_type)
  return _s;
}
inline const std::string& CustomField::_internal_field_type() const {
  return field_type_.Get();
}
inline void CustomField::_internal_set_field_type(const std::string& value) {
  
  field_type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CustomField::_internal_mutable_field_type() {
  
  return field_type_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CustomField::release_field_type() {
  // @@protoc_insertion_point(field_release:keeptower.CustomField.field_type)
  return field_type_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CustomField::set_allocated_field_type(std::string* field_type) {
  if (field_type != nullptr) {
    
  } else {
    
  }
  field_type_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), field_type,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (field_type_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    field_type_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:keeptower.CustomField.field_type)
}

// -------------------------------------------------------------------

// GroupMembership

// string group_id = 1;
inline void GroupMembership::clear_group_id() {
  group_id_.ClearToEmpty();
}
inline const std::string& GroupMembership::group_id() const {
  // @@protoc_insertion_point(field_get:keeptower.GroupMembership.group_id)
  return _internal_group_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GroupMembership::set_group_id(ArgT0&& arg0, ArgT... args) {
 
 group_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:keeptower.GroupMembership.group_id)
}
inline std::string* GroupMembership::mutable_group_id() {
  std::string* _s = _internal_mutable_group_id();
  // @@protoc_insertion_point(field_mutable:keeptower.GroupMembership.group_id)
  return _s;
}
inline const std::string& GroupMembership::_internal_group_id() const {
  return group_id_.Get();
}
inline void GroupMembership::_internal_set_group_id(const std::string& value) {
  
  group_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GroupMembership::_internal_mutable_group_id() {
  
  return group_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GroupMembership::release_group_id() {
  // @@protoc_insertion_point(field_release:keeptower.GroupMembership.group_id)
  return group_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GroupMembership::set_allocated_group_id(std::string* group_id) {
  if (group_id != nullptr) {
    
  } else {
    
  }
  group_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), group_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (group_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    group_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:keeptower.GroupMembership.group_id)
}

// int32 display_order = 2;
inline void GroupMembership::clear_display_order() {
  display_order_ = 0;
}
inline int32_t GroupMembership::_internal_display_order() const {
  return display_order_;
}
inline int32_t GroupMembership::display_order() const {
  // @@protoc_insertion_point(field_get:keeptower.GroupMembership.display_order)
  return _internal_display_order();
}
inline void GroupMembership::_internal_set_display_order(int32_t value) {
  
  display_order_ = value;
}
inline void GroupMembership::set_display_order(int32_t value) {
  _internal_set_display_order(value);
  // @@protoc_insertion_point(field_set:keeptower.GroupMembership.display_order)
}

// -------------------------------------------------------------------

// AccountGroup

// string group_id = 1;
inline void AccountGroup::clear_group_id() {
  group_id_.ClearToEmpty();
}
inline const std::string& AccountGroup::group_id() const {
  // @@protoc_insertion_point(field_get:keeptower.AccountGroup.group_id)
  return _internal_group_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AccountGroup::set_group_id(ArgT0&& arg0, ArgT... args) {
 
 group_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:keeptower.AccountGroup.group_id)
}
inline std::string* AccountGroup::mutable_group_id() {
  std::string* _s = _internal_mutable_group_id();
  // @@protoc_insertion_point(field_mutable:keeptower.AccountGroup.group_id)
  return _s;
}
inline const std::string& AccountGroup::_internal_group_id() const {
  return group_id_.Get();
}
inline void AccountGroup::_internal_set_group_id(const std::string& value) {
  
  group_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* AccountGroup::_internal_mutable_group_id() {
  
  return group_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AccountGroup::release_group_id() {
  // @@protoc_insertion_point(field_release:keeptower.AccountGroup.group_id)
  return group_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void AccountGroup::set_allocated_group_id(std::string* group_id) {
  if (group_id != nullptr) {
    
  } else {
    
  }
  group_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), group_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (group_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    group_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:keeptower.AccountGroup.group_id)
}

// string group_name = 2;
inline void AccountGroup::clear_group_name() {
  group_name_.ClearToEmpty();
}
inline const std::string& AccountGroup::group_name() const {
  // @@protoc_insertion_point(field_get:keeptower.AccountGroup.group_name)
  return _internal_group_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AccountGroup::set_group_name(ArgT0&& arg0, ArgT... args) {
 
 group_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:keeptower.AccountGroup.group_name)
}
inline std::string* AccountGroup::mutable_group_name() {
  std::string* _s = _internal_mutable_group_name();
  // @@protoc_insertion_point(field_mutable:keeptower.AccountGroup.group_name)
  return _s;
}
inline const std::string& AccountGroup::_internal_group_name() const {
  return group_name_.Get();
}
inline void AccountGroup::_internal_set_group_name(const std::string& value) {
  
  group_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* AccountGroup::_internal_mutable_group_name() {
  
  return group_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AccountGroup::release_group_name() {
  // @@protoc_insertion_point(field_release:keeptower.AccountGroup.group_name)
  return group_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void AccountGroup::set_allocated_group_name(std::string* group_name) {
  if (group_name != nullptr) {
    
  } else {
    
  }
  group_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), group_name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (group_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    group_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:keeptower.AccountGroup.group_name)
}

// int32 display_order = 3;
inline void AccountGroup::clear_display_order() {
  display_order_ = 0;
}
inline int32_t AccountGroup::_internal_display_order() const {
  return display_order_;
}
inline int32_t AccountGroup::display_order() const {
  // @@protoc_insertion_point(field_get:keeptower.AccountGroup.display_order)
  return _internal_display_order();
}
inline void AccountGroup::_internal_set_display_order(int32_t value) {
  
  display_order_ = value;
}
inline void AccountGroup::set_display_order(int32_t value) {
  _internal_set_display_order(value);
  // @@protoc_insertion_point(field_set:keeptower.AccountGroup.display_order)
}

// bool is_expanded = 4;
inline void AccountGroup::clear_is_expanded() {
  is_expanded_ = false;
}
inline bool AccountGroup::_internal_is_expanded() const {
  return is_expanded_;
}
inline bool AccountGroup::is_expanded() const {
  // @@protoc_insertion_point(field_get:keeptower.AccountGroup.is_expanded)
  return _internal_is_expanded();
}
inline void AccountGroup::_internal_set_is_expanded(bool value) {
  
  is_expanded_ = value;
}
inline void AccountGroup::set_is_expanded(bool value) {
  _internal_set_is_expanded(value);
  // @@protoc_insertion_point(field_set:keeptower.AccountGroup.is_expanded)
}

// bool is_system_group = 5;
inline void AccountGroup::clear_is_system_group() {
  is_system_group_ = false;
}
inline bool AccountGroup::_internal_is_system_group() const {
  return is_system_group_;
}
inline bool AccountGroup::is_system_group() const {
  // @@protoc_insertion_point(field_get:keeptower.AccountGroup.is_system_group)
  return _internal_is_system_group();
}
inline void AccountGroup::_internal_set_is_system_group(bool value) {
  
  is_system_group_ = value;
}
inline void AccountGroup::set_is_system_group(bool value) {
  _internal_set_is_system_group(value);
  // @@protoc_insertion_point(field_set:keeptower.AccountGroup.is_system_group)
}

// string description = 6;
inline void AccountGroup::clear_description() {
  description_.ClearToEmpty();
}
inline const std::string& AccountGroup::description() const {
  // @@protoc_insertion_point(field_get:keeptower.AccountGroup.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AccountGroup::set_description(ArgT0&& arg0, ArgT... args) {
 
 description_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:keeptower.AccountGroup.description)
}
inline std::string* AccountGroup::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:keeptower.AccountGroup.description)
  return _s;
}
inline const std::string& AccountGroup::_internal_description() const {
  return description_.Get();
}
inline void AccountGroup::_internal_set_description(const std::string& value) {
  
  description_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* AccountGroup::_internal_mutable_description() {
  
  return description_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AccountGroup::release_description() {
  // @@protoc_insertion_point(field_release:keeptower.AccountGroup.description)
  return description_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void AccountGroup::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    
  } else {
    
  }
  description_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), description,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (description_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    description_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:keeptower.AccountGroup.description)
}

// string color = 7;
inline void AccountGroup::clear_color() {
  color_.ClearToEmpty();
}
inline const std::string& AccountGroup::color() const {
  // @@protoc_insertion_point(field_get:keeptower.AccountGroup.color)
  return _internal_color();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AccountGroup::set_color(ArgT0&& arg0, ArgT... args) {
 
 color_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:keeptower.AccountGroup.color)
}
inline std::string* AccountGroup::mutable_color() {
  std::string* _s = _internal_mutable_color();
  // @@protoc_insertion_point(field_mutable:keeptower.AccountGroup.color)
  return _s;
}
inline const std::string& AccountGroup::_internal_color() const {
  return color_.Get();
}
inline void AccountGroup::_internal_set_color(const std::string& value) {
  
  color_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* AccountGroup::_internal_mutable_color() {
  
  return color_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AccountGroup::release_color() {
  // @@protoc_insertion_point(field_release:keeptower.AccountGroup.color)
  return color_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void AccountGroup::set_allocated_color(std::string* color) {
  if (color != nullptr) {
    
  } else {
    
  }
  color_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), color,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (color_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    color_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:keeptower.AccountGroup.color)
}

// string icon = 8;
inline void AccountGroup::clear_icon() {
  icon_.ClearToEmpty();
}
inline const std::string& AccountGroup::icon() const {
  // @@protoc_insertion_point(field_get:keeptower.AccountGroup.icon)
  return _internal_icon();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AccountGroup::set_icon(ArgT0&& arg0, ArgT... args) {
 
 icon_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:keeptower.AccountGroup.icon)
}
inline std::string* AccountGroup::mutable_icon() {
  std::string* _s = _internal_mutable_icon();
  // @@protoc_insertion_point(field_mutable:keeptower.AccountGroup.icon)
  return _s;
}
inline const std::string& AccountGroup::_internal_icon() const {
  return icon_.Get();
}
inline void AccountGroup::_internal_set_icon(const std::string& value) {
  
  icon_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* AccountGroup::_internal_mutable_icon() {
  
  return icon_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AccountGroup::release_icon() {
  // @@protoc_insertion_point(field_release:keeptower.AccountGroup.icon)
  return icon_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void AccountGroup::set_allocated_icon(std::string* icon) {
  if (icon != nullptr) {
    
  } else {
    
  }
  icon_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), icon,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (icon_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    icon_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:keeptower.AccountGroup.icon)
}

// -------------------------------------------------------------------

// AccountRecord

// string id = 1;
inline void AccountRecord::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& AccountRecord::id() const {
  // @@protoc_insertion_point(field_get:keeptower.AccountRecord.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AccountRecord::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:keeptower.AccountRecord.id)
}
inline std::string* AccountRecord::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:keeptower.AccountRecord.id)
  return _s;
}
inline const std::string& AccountRecord::_internal_id() const {
  return id_.Get();
}
inline void AccountRecord::_internal_set_id(const std::string& value) {
  
  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* AccountRecord::_internal_mutable_id() {
  
  return id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AccountRecord::release_id() {
  // @@protoc_insertion_point(field_release:keeptower.AccountRecord.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void AccountRecord::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:keeptower.AccountRecord.id)
}

// string account_name = 2;
inline void AccountRecord::clear_account_name() {
  account_name_.ClearToEmpty();
}
inline const std::string& AccountRecord::account_name() const {
  // @@protoc_insertion_point(field_get:keeptower.AccountRecord.account_name)
  return _internal_account_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AccountRecord::set_account_name(ArgT0&& arg0, ArgT... args) {
 
 account_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:keeptower.AccountRecord.account_name)
}
inline std::string* AccountRecord::mutable_account_name() {
  std::string* _s = _internal_mutable_account_name();
  // @@protoc_insertion_point(field_mutable:keeptower.AccountRecord.account_name)
  return _s;
}
inline const std::string& AccountRecord::_internal_account_name() const {
  return account_name_.Get();
}
inline void AccountRecord::_internal_set_account_name(const std::string& value) {
  
  account_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* AccountRecord::_internal_mutable_account_name() {
  
  return account_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AccountRecord::release_account_name() {
  // @@protoc_insertion_point(field_release:keeptower.AccountRecord.account_name)
  return account_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void AccountRecord::set_allocated_account_name(std::string* account_name) {
  if (account_name != nullptr) {
    
  } else {
    
  }
  account_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), account_name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (account_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    account_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:keeptower.AccountRecord.account_name)
}

// string user_name = 3;
inline void AccountRecord::clear_user_name() {
  user_name_.ClearToEmpty();
}
inline const std::string& AccountRecord::user_name() const {
  // @@protoc_insertion_point(field_get:keeptower.AccountRecord.user_name)
  return _internal_user_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AccountRecord::set_user_name(ArgT0&& arg0, ArgT... args) {
 
 user_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:keeptower.AccountRecord.user_name)
}
inline std::string* AccountRecord::mutable_user_name() {
  std::string* _s = _internal_mutable_user_name();
  // @@protoc_insertion_point(field_mutable:keeptower.AccountRecord.user_name)
  return _s;
}
inline const std::string& AccountRecord::_internal_user_name() const {
  return user_name_.Get();
}
inline void AccountRecord::_internal_set_user_name(const std::string& value) {
  
  user_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* AccountRecord::_internal_mutable_user_name() {
  
  return user_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AccountRecord::release_user_name() {
  // @@protoc_insertion_point(field_release:keeptower.AccountRecord.user_name)
  return user_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void AccountRecord::set_allocated_user_name(std::string* user_name) {
  if (user_name != nullptr) {
    
  } else {
    
  }
  user_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), user_name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (user_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    user_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:keeptower.AccountRecord.user_name)
}

// string password = 4;
inline void AccountRecord::clear_password() {
  password_.ClearToEmpty();
}
inline const std::string& AccountRecord::password() const {
  // @@protoc_insertion_point(field_get:keeptower.AccountRecord.password)
  return _internal_password();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AccountRecord::set_password(ArgT0&& arg0, ArgT... args) {
 
 password_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:keeptower.AccountRecord.password)
}
inline std::string* AccountRecord::mutable_password() {
  std::string* _s = _internal_mutable_password();
  // @@protoc_insertion_point(field_mutable:keeptower.AccountRecord.password)
  return _s;
}
inline const std::string& AccountRecord::_internal_password() const {
  return password_.Get();
}
inline void AccountRecord::_internal_set_password(const std::string& value) {
  
  password_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* AccountRecord::_internal_mutable_password() {
  
  return password_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AccountRecord::release_password() {
  // @@protoc_insertion_point(field_release:keeptower.AccountRecord.password)
  return password_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void AccountRecord::set_allocated_password(std::string* password) {
  if (password != nullptr) {
    
  } else {
    
  }
  password_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), password,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (password_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    password_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:keeptower.AccountRecord.password)
}

// string email = 5;
inline void AccountRecord::clear_email() {
  email_.ClearToEmpty();
}
inline const std::string& AccountRecord::email() const {
  // @@protoc_insertion_point(field_get:keeptower.AccountRecord.email)
  return _internal_email();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AccountRecord::set_email(ArgT0&& arg0, ArgT... args) {
 
 email_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:keeptower.AccountRecord.email)
}
inline std::string* AccountRecord::mutable_email() {
  std::string* _s = _internal_mutable_email();
  // @@protoc_insertion_point(field_mutable:keeptower.AccountRecord.email)
  return _s;
}
inline const std::string& AccountRecord::_internal_email() const {
  return email_.Get();
}
inline void AccountRecord::_internal_set_email(const std::string& value) {
  
  email_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* AccountRecord::_internal_mutable_email() {
  
  return email_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AccountRecord::release_email() {
  // @@protoc_insertion_point(field_release:keeptower.AccountRecord.email)
  return email_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void AccountRecord::set_allocated_email(std::string* email) {
  if (email != nullptr) {
    
  } else {
    
  }
  email_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), email,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (email_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    email_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:keeptower.AccountRecord.email)
}

// string website = 6;
inline void AccountRecord::clear_website() {
  website_.ClearToEmpty();
}
inline const std::string& AccountRecord::website() const {
  // @@protoc_insertion_point(field_get:keeptower.AccountRecord.website)
  return _internal_website();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AccountRecord::set_website(ArgT0&& arg0, ArgT... args) {
 
 website_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:keeptower.AccountRecord.website)
}
inline std::string* AccountRecord::mutable_website() {
  std::string* _s = _internal_mutable_website();
  // @@protoc_insertion_point(field_mutable:keeptower.AccountRecord.website)
  return _s;
}
inline const std::string& AccountRecord::_internal_website() const {
  return website_.Get();
}
inline void AccountRecord::_internal_set_website(const std::string& value) {
  
  website_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* AccountRecord::_internal_mutable_website() {
  
  return website_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AccountRecord::release_website() {
  // @@protoc_insertion_point(field_release:keeptower.AccountRecord.website)
  return website_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void AccountRecord::set_allocated_website(std::string* website) {
  if (website != nullptr) {
    
  } else {
    
  }
  website_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), website,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (website_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    website_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:keeptower.AccountRecord.website)
}

// int64 created_at = 16;
inline void AccountRecord::clear_created_at() {
  created_at_ = int64_t{0};
}
inline int64_t AccountRecord::_internal_created_at() const {
  return created_at_;
}
inline int64_t AccountRecord::created_at() const {
  // @@protoc_insertion_point(field_get:keeptower.AccountRecord.created_at)
  return _internal_created_at();
}
inline void AccountRecord::_internal_set_created_at(int64_t value) {
  
  created_at_ = value;
}
inline void AccountRecord::set_created_at(int64_t value) {
  _internal_set_created_at(value);
  // @@protoc_insertion_point(field_set:keeptower.AccountRecord.created_at)
}

// int64 modified_at = 17;
inline void AccountRecord::clear_modified_at() {
  modified_at_ = int64_t{0};
}
inline int64_t AccountRecord::_internal_modified_at() const {
  return modified_at_;
}
inline int64_t AccountRecord::modified_at() const {
  // @@protoc_insertion_point(field_get:keeptower.AccountRecord.modified_at)
  return _internal_modified_at();
}
inline void AccountRecord::_internal_set_modified_at(int64_t value) {
  
  modified_at_ = value;
}
inline void AccountRecord::set_modified_at(int64_t value) {
  _internal_set_modified_at(value);
  // @@protoc_insertion_point(field_set:keeptower.AccountRecord.modified_at)
}

// int64 password_changed_at = 18;
inline void AccountRecord::clear_password_changed_at() {
  password_changed_at_ = int64_t{0};
}
inline int64_t AccountRecord::_internal_password_changed_at() const {
  return password_changed_at_;
}
inline int64_t AccountRecord::password_changed_at() const {
  // @@protoc_insertion_point(field_get:keeptower.AccountRecord.password_changed_at)
  return _internal_password_changed_at();
}
inline void AccountRecord::_internal_set_password_changed_at(int64_t value) {
  
  password_changed_at_ = value;
}
inline void AccountRecord::set_password_changed_at(int64_t value) {
  _internal_set_password_changed_at(value);
  // @@protoc_insertion_point(field_set:keeptower.AccountRecord.password_changed_at)
}

// string notes = 19;
inline void AccountRecord::clear_notes() {
  notes_.ClearToEmpty();
}
inline const std::string& AccountRecord::notes() const {
  // @@protoc_insertion_point(field_get:keeptower.AccountRecord.notes)
  return _internal_notes();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AccountRecord::set_notes(ArgT0&& arg0, ArgT... args) {
 
 notes_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:keeptower.AccountRecord.notes)
}
inline std::string* AccountRecord::mutable_notes() {
  std::string* _s = _internal_mutable_notes();
  // @@protoc_insertion_point(field_mutable:keeptower.AccountRecord.notes)
  return _s;
}
inline const std::string& AccountRecord::_internal_notes() const {
  return notes_.Get();
}
inline void AccountRecord::_internal_set_notes(const std::string& value) {
  
  notes_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* AccountRecord::_internal_mutable_notes() {
  
  return notes_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AccountRecord::release_notes() {
  // @@protoc_insertion_point(field_release:keeptower.AccountRecord.notes)
  return notes_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void AccountRecord::set_allocated_notes(std::string* notes) {
  if (notes != nullptr) {
    
  } else {
    
  }
  notes_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), notes,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (notes_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    notes_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:keeptower.AccountRecord.notes)
}

// repeated string tags = 20;
inline int AccountRecord::_internal_tags_size() const {
  return tags_.size();
}
inline int AccountRecord::tags_size() const {
  return _internal_tags_size();
}
inline void AccountRecord::clear_tags() {
  tags_.Clear();
}
inline std::string* AccountRecord::add_tags() {
  std::string* _s = _internal_add_tags();
  // @@protoc_insertion_point(field_add_mutable:keeptower.AccountRecord.tags)
  return _s;
}
inline const std::string& AccountRecord::_internal_tags(int index) const {
  return tags_.Get(index);
}
inline const std::string& AccountRecord::tags(int index) const {
  // @@protoc_insertion_point(field_get:keeptower.AccountRecord.tags)
  return _internal_tags(index);
}
inline std::string* AccountRecord::mutable_tags(int index) {
  // @@protoc_insertion_point(field_mutable:keeptower.AccountRecord.tags)
  return tags_.Mutable(index);
}
inline void AccountRecord::set_tags(int index, const std::string& value) {
  tags_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:keeptower.AccountRecord.tags)
}
inline void AccountRecord::set_tags(int index, std::string&& value) {
  tags_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:keeptower.AccountRecord.tags)
}
inline void AccountRecord::set_tags(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  tags_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:keeptower.AccountRecord.tags)
}
inline void AccountRecord::set_tags(int index, const char* value, size_t size) {
  tags_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:keeptower.AccountRecord.tags)
}
inline std::string* AccountRecord::_internal_add_tags() {
  return tags_.Add();
}
inline void AccountRecord::add_tags(const std::string& value) {
  tags_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:keeptower.AccountRecord.tags)
}
inline void AccountRecord::add_tags(std::string&& value) {
  tags_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:keeptower.AccountRecord.tags)
}
inline void AccountRecord::add_tags(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  tags_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:keeptower.AccountRecord.tags)
}
inline void AccountRecord::add_tags(const char* value, size_t size) {
  tags_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:keeptower.AccountRecord.tags)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
AccountRecord::tags() const {
  // @@protoc_insertion_point(field_list:keeptower.AccountRecord.tags)
  return tags_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
AccountRecord::mutable_tags() {
  // @@protoc_insertion_point(field_mutable_list:keeptower.AccountRecord.tags)
  return &tags_;
}

// bool is_favorite = 21;
inline void AccountRecord::clear_is_favorite() {
  is_favorite_ = false;
}
inline bool AccountRecord::_internal_is_favorite() const {
  return is_favorite_;
}
inline bool AccountRecord::is_favorite() const {
  // @@protoc_insertion_point(field_get:keeptower.AccountRecord.is_favorite)
  return _internal_is_favorite();
}
inline void AccountRecord::_internal_set_is_favorite(bool value) {
  
  is_favorite_ = value;
}
inline void AccountRecord::set_is_favorite(bool value) {
  _internal_set_is_favorite(value);
  // @@protoc_insertion_point(field_set:keeptower.AccountRecord.is_favorite)
}

// bool is_archived = 22;
inline void AccountRecord::clear_is_archived() {
  is_archived_ = false;
}
inline bool AccountRecord::_internal_is_archived() const {
  return is_archived_;
}
inline bool AccountRecord::is_archived() const {
  // @@protoc_insertion_point(field_get:keeptower.AccountRecord.is_archived)
  return _internal_is_archived();
}
inline void AccountRecord::_internal_set_is_archived(bool value) {
  
  is_archived_ = value;
}
inline void AccountRecord::set_is_archived(bool value) {
  _internal_set_is_archived(value);
  // @@protoc_insertion_point(field_set:keeptower.AccountRecord.is_archived)
}

// string color = 23;
inline void AccountRecord::clear_color() {
  color_.ClearToEmpty();
}
inline const std::string& AccountRecord::color() const {
  // @@protoc_insertion_point(field_get:keeptower.AccountRecord.color)
  return _internal_color();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AccountRecord::set_color(ArgT0&& arg0, ArgT... args) {
 
 color_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:keeptower.AccountRecord.color)
}
inline std::string* AccountRecord::mutable_color() {
  std::string* _s = _internal_mutable_color();
  // @@protoc_insertion_point(field_mutable:keeptower.AccountRecord.color)
  return _s;
}
inline const std::string& AccountRecord::_internal_color() const {
  return color_.Get();
}
inline void AccountRecord::_internal_set_color(const std::string& value) {
  
  color_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* AccountRecord::_internal_mutable_color() {
  
  return color_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AccountRecord::release_color() {
  // @@protoc_insertion_point(field_release:keeptower.AccountRecord.color)
  return color_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void AccountRecord::set_allocated_color(std::string* color) {
  if (color != nullptr) {
    
  } else {
    
  }
  color_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), color,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (color_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    color_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:keeptower.AccountRecord.color)
}

// string icon = 24;
inline void AccountRecord::clear_icon() {
  icon_.ClearToEmpty();
}
inline const std::string& AccountRecord::icon() const {
  // @@protoc_insertion_point(field_get:keeptower.AccountRecord.icon)
  return _internal_icon();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AccountRecord::set_icon(ArgT0&& arg0, ArgT... args) {
 
 icon_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:keeptower.AccountRecord.icon)
}
inline std::string* AccountRecord::mutable_icon() {
  std::string* _s = _internal_mutable_icon();
  // @@protoc_insertion_point(field_mutable:keeptower.AccountRecord.icon)
  return _s;
}
inline const std::string& AccountRecord::_internal_icon() const {
  return icon_.Get();
}
inline void AccountRecord::_internal_set_icon(const std::string& value) {
  
  icon_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* AccountRecord::_internal_mutable_icon() {
  
  return icon_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AccountRecord::release_icon() {
  // @@protoc_insertion_point(field_release:keeptower.AccountRecord.icon)
  return icon_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void AccountRecord::set_allocated_icon(std::string* icon) {
  if (icon != nullptr) {
    
  } else {
    
  }
  icon_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), icon,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (icon_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    icon_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:keeptower.AccountRecord.icon)
}

// int32 global_display_order = 25;
inline void AccountRecord::clear_global_display_order() {
  global_display_order_ = 0;
}
inline int32_t AccountRecord::_internal_global_display_order() const {
  return global_display_order_;
}
inline int32_t AccountRecord::global_display_order() const {
  // @@protoc_insertion_point(field_get:keeptower.AccountRecord.global_display_order)
  return _internal_global_display_order();
}
inline void AccountRecord::_internal_set_global_display_order(int32_t value) {
  
  global_display_order_ = value;
}
inline void AccountRecord::set_global_display_order(int32_t value) {
  _internal_set_global_display_order(value);
  // @@protoc_insertion_point(field_set:keeptower.AccountRecord.global_display_order)
}

// bool is_admin_only_viewable = 26;
inline void AccountRecord::clear_is_admin_only_viewable() {
  is_admin_only_viewable_ = false;
}
inline bool AccountRecord::_internal_is_admin_only_viewable() const {
  return is_admin_only_viewable_;
}
inline bool AccountRecord::is_admin_only_viewable() const {
  // @@protoc_insertion_point(field_get:keeptower.AccountRecord.is_admin_only_viewable)
  return _internal_is_admin_only_viewable();
}
inline void AccountRecord::_internal_set_is_admin_only_viewable(bool value) {
  
  is_admin_only_viewable_ = value;
}
inline void AccountRecord::set_is_admin_only_viewable(bool value) {
  _internal_set_is_admin_only_viewable(value);
  // @@protoc_insertion_point(field_set:keeptower.AccountRecord.is_admin_only_viewable)
}

// bool is_admin_only_deletable = 27;
inline void AccountRecord::clear_is_admin_only_deletable() {
  is_admin_only_deletable_ = false;
}
inline bool AccountRecord::_internal_is_admin_only_deletable() const {
  return is_admin_only_deletable_;
}
inline bool AccountRecord::is_admin_only_deletable() const {
  // @@protoc_insertion_point(field_get:keeptower.AccountRecord.is_admin_only_deletable)
  return _internal_is_admin_only_deletable();
}
inline void AccountRecord::_internal_set_is_admin_only_deletable(bool value) {
  
  is_admin_only_deletable_ = value;
}
inline void AccountRecord::set_is_admin_only_deletable(bool value) {
  _internal_set_is_admin_only_deletable(value);
  // @@protoc_insertion_point(field_set:keeptower.AccountRecord.is_admin_only_deletable)
}

// .keeptower.TOTPConfig totp = 32;
inline bool AccountRecord::_internal_has_totp() const {
  return this != internal_default_instance() && totp_ != nullptr;
}
inline bool AccountRecord::has_totp() const {
  return _internal_has_totp();
}
inline void AccountRecord::clear_totp() {
  if (GetArenaForAllocation() == nullptr && totp_ != nullptr) {
    delete totp_;
  }
  totp_ = nullptr;
}
inline const ::keeptower::TOTPConfig& AccountRecord::_internal_totp() const {
  const ::keeptower::TOTPConfig* p = totp_;
  return p != nullptr ? *p : reinterpret_cast<const ::keeptower::TOTPConfig&>(
      ::keeptower::_TOTPConfig_default_instance_);
}
inline const ::keeptower::TOTPConfig& AccountRecord::totp() const {
  // @@protoc_insertion_point(field_get:keeptower.AccountRecord.totp)
  return _internal_totp();
}
inline void AccountRecord::unsafe_arena_set_allocated_totp(
    ::keeptower::TOTPConfig* totp) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(totp_);
  }
  totp_ = totp;
  if (totp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:keeptower.AccountRecord.totp)
}
inline ::keeptower::TOTPConfig* AccountRecord::release_totp() {
  
  ::keeptower::TOTPConfig* temp = totp_;
  totp_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::keeptower::TOTPConfig* AccountRecord::unsafe_arena_release_totp() {
  // @@protoc_insertion_point(field_release:keeptower.AccountRecord.totp)
  
  ::keeptower::TOTPConfig* temp = totp_;
  totp_ = nullptr;
  return temp;
}
inline ::keeptower::TOTPConfig* AccountRecord::_internal_mutable_totp() {
  
  if (totp_ == nullptr) {
    auto* p = CreateMaybeMessage<::keeptower::TOTPConfig>(GetArenaForAllocation());
    totp_ = p;
  }
  return totp_;
}
inline ::keeptower::TOTPConfig* AccountRecord::mutable_totp() {
  ::keeptower::TOTPConfig* _msg = _internal_mutable_totp();
  // @@protoc_insertion_point(field_mutable:keeptower.AccountRecord.totp)
  return _msg;
}
inline void AccountRecord::set_allocated_totp(::keeptower::TOTPConfig* totp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete totp_;
  }
  if (totp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::keeptower::TOTPConfig>::GetOwningArena(totp);
    if (message_arena != submessage_arena) {
      totp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, totp, submessage_arena);
    }
    
  } else {
    
  }
  totp_ = totp;
  // @@protoc_insertion_point(field_set_allocated:keeptower.AccountRecord.totp)
}

// repeated .keeptower.CustomField custom_fields = 33;
inline int AccountRecord::_internal_custom_fields_size() const {
  return custom_fields_.size();
}
inline int AccountRecord::custom_fields_size() const {
  return _internal_custom_fields_size();
}
inline void AccountRecord::clear_custom_fields() {
  custom_fields_.Clear();
}
inline ::keeptower::CustomField* AccountRecord::mutable_custom_fields(int index) {
  // @@protoc_insertion_point(field_mutable:keeptower.AccountRecord.custom_fields)
  return custom_fields_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::keeptower::CustomField >*
AccountRecord::mutable_custom_fields() {
  // @@protoc_insertion_point(field_mutable_list:keeptower.AccountRecord.custom_fields)
  return &custom_fields_;
}
inline const ::keeptower::CustomField& AccountRecord::_internal_custom_fields(int index) const {
  return custom_fields_.Get(index);
}
inline const ::keeptower::CustomField& AccountRecord::custom_fields(int index) const {
  // @@protoc_insertion_point(field_get:keeptower.AccountRecord.custom_fields)
  return _internal_custom_fields(index);
}
inline ::keeptower::CustomField* AccountRecord::_internal_add_custom_fields() {
  return custom_fields_.Add();
}
inline ::keeptower::CustomField* AccountRecord::add_custom_fields() {
  ::keeptower::CustomField* _add = _internal_add_custom_fields();
  // @@protoc_insertion_point(field_add:keeptower.AccountRecord.custom_fields)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::keeptower::CustomField >&
AccountRecord::custom_fields() const {
  // @@protoc_insertion_point(field_list:keeptower.AccountRecord.custom_fields)
  return custom_fields_;
}

// repeated .keeptower.CustomField security_questions = 34;
inline int AccountRecord::_internal_security_questions_size() const {
  return security_questions_.size();
}
inline int AccountRecord::security_questions_size() const {
  return _internal_security_questions_size();
}
inline void AccountRecord::clear_security_questions() {
  security_questions_.Clear();
}
inline ::keeptower::CustomField* AccountRecord::mutable_security_questions(int index) {
  // @@protoc_insertion_point(field_mutable:keeptower.AccountRecord.security_questions)
  return security_questions_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::keeptower::CustomField >*
AccountRecord::mutable_security_questions() {
  // @@protoc_insertion_point(field_mutable_list:keeptower.AccountRecord.security_questions)
  return &security_questions_;
}
inline const ::keeptower::CustomField& AccountRecord::_internal_security_questions(int index) const {
  return security_questions_.Get(index);
}
inline const ::keeptower::CustomField& AccountRecord::security_questions(int index) const {
  // @@protoc_insertion_point(field_get:keeptower.AccountRecord.security_questions)
  return _internal_security_questions(index);
}
inline ::keeptower::CustomField* AccountRecord::_internal_add_security_questions() {
  return security_questions_.Add();
}
inline ::keeptower::CustomField* AccountRecord::add_security_questions() {
  ::keeptower::CustomField* _add = _internal_add_security_questions();
  // @@protoc_insertion_point(field_add:keeptower.AccountRecord.security_questions)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::keeptower::CustomField >&
AccountRecord::security_questions() const {
  // @@protoc_insertion_point(field_list:keeptower.AccountRecord.security_questions)
  return security_questions_;
}

// repeated string password_history = 35;
inline int AccountRecord::_internal_password_history_size() const {
  return password_history_.size();
}
inline int AccountRecord::password_history_size() const {
  return _internal_password_history_size();
}
inline void AccountRecord::clear_password_history() {
  password_history_.Clear();
}
inline std::string* AccountRecord::add_password_history() {
  std::string* _s = _internal_add_password_history();
  // @@protoc_insertion_point(field_add_mutable:keeptower.AccountRecord.password_history)
  return _s;
}
inline const std::string& AccountRecord::_internal_password_history(int index) const {
  return password_history_.Get(index);
}
inline const std::string& AccountRecord::password_history(int index) const {
  // @@protoc_insertion_point(field_get:keeptower.AccountRecord.password_history)
  return _internal_password_history(index);
}
inline std::string* AccountRecord::mutable_password_history(int index) {
  // @@protoc_insertion_point(field_mutable:keeptower.AccountRecord.password_history)
  return password_history_.Mutable(index);
}
inline void AccountRecord::set_password_history(int index, const std::string& value) {
  password_history_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:keeptower.AccountRecord.password_history)
}
inline void AccountRecord::set_password_history(int index, std::string&& value) {
  password_history_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:keeptower.AccountRecord.password_history)
}
inline void AccountRecord::set_password_history(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  password_history_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:keeptower.AccountRecord.password_history)
}
inline void AccountRecord::set_password_history(int index, const char* value, size_t size) {
  password_history_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:keeptower.AccountRecord.password_history)
}
inline std::string* AccountRecord::_internal_add_password_history() {
  return password_history_.Add();
}
inline void AccountRecord::add_password_history(const std::string& value) {
  password_history_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:keeptower.AccountRecord.password_history)
}
inline void AccountRecord::add_password_history(std::string&& value) {
  password_history_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:keeptower.AccountRecord.password_history)
}
inline void AccountRecord::add_password_history(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  password_history_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:keeptower.AccountRecord.password_history)
}
inline void AccountRecord::add_password_history(const char* value, size_t size) {
  password_history_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:keeptower.AccountRecord.password_history)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
AccountRecord::password_history() const {
  // @@protoc_insertion_point(field_list:keeptower.AccountRecord.password_history)
  return password_history_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
AccountRecord::mutable_password_history() {
  // @@protoc_insertion_point(field_mutable_list:keeptower.AccountRecord.password_history)
  return &password_history_;
}

// string recovery_email = 36;
inline void AccountRecord::clear_recovery_email() {
  recovery_email_.ClearToEmpty();
}
inline const std::string& AccountRecord::recovery_email() const {
  // @@protoc_insertion_point(field_get:keeptower.AccountRecord.recovery_email)
  return _internal_recovery_email();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AccountRecord::set_recovery_email(ArgT0&& arg0, ArgT... args) {
 
 recovery_email_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:keeptower.AccountRecord.recovery_email)
}
inline std::string* AccountRecord::mutable_recovery_email() {
  std::string* _s = _internal_mutable_recovery_email();
  // @@protoc_insertion_point(field_mutable:keeptower.AccountRecord.recovery_email)
  return _s;
}
inline const std::string& AccountRecord::_internal_recovery_email() const {
  return recovery_email_.Get();
}
inline void AccountRecord::_internal_set_recovery_email(const std::string& value) {
  
  recovery_email_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* AccountRecord::_internal_mutable_recovery_email() {
  
  return recovery_email_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AccountRecord::release_recovery_email() {
  // @@protoc_insertion_point(field_release:keeptower.AccountRecord.recovery_email)
  return recovery_email_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void AccountRecord::set_allocated_recovery_email(std::string* recovery_email) {
  if (recovery_email != nullptr) {
    
  } else {
    
  }
  recovery_email_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), recovery_email,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (recovery_email_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    recovery_email_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:keeptower.AccountRecord.recovery_email)
}

// string recovery_phone = 37;
inline void AccountRecord::clear_recovery_phone() {
  recovery_phone_.ClearToEmpty();
}
inline const std::string& AccountRecord::recovery_phone() const {
  // @@protoc_insertion_point(field_get:keeptower.AccountRecord.recovery_phone)
  return _internal_recovery_phone();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AccountRecord::set_recovery_phone(ArgT0&& arg0, ArgT... args) {
 
 recovery_phone_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:keeptower.AccountRecord.recovery_phone)
}
inline std::string* AccountRecord::mutable_recovery_phone() {
  std::string* _s = _internal_mutable_recovery_phone();
  // @@protoc_insertion_point(field_mutable:keeptower.AccountRecord.recovery_phone)
  return _s;
}
inline const std::string& AccountRecord::_internal_recovery_phone() const {
  return recovery_phone_.Get();
}
inline void AccountRecord::_internal_set_recovery_phone(const std::string& value) {
  
  recovery_phone_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* AccountRecord::_internal_mutable_recovery_phone() {
  
  return recovery_phone_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AccountRecord::release_recovery_phone() {
  // @@protoc_insertion_point(field_release:keeptower.AccountRecord.recovery_phone)
  return recovery_phone_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void AccountRecord::set_allocated_recovery_phone(std::string* recovery_phone) {
  if (recovery_phone != nullptr) {
    
  } else {
    
  }
  recovery_phone_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), recovery_phone,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (recovery_phone_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    recovery_phone_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:keeptower.AccountRecord.recovery_phone)
}

// repeated .keeptower.GroupMembership groups = 38;
inline int AccountRecord::_internal_groups_size() const {
  return groups_.size();
}
inline int AccountRecord::groups_size() const {
  return _internal_groups_size();
}
inline void AccountRecord::clear_groups() {
  groups_.Clear();
}
inline ::keeptower::GroupMembership* AccountRecord::mutable_groups(int index) {
  // @@protoc_insertion_point(field_mutable:keeptower.AccountRecord.groups)
  return groups_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::keeptower::GroupMembership >*
AccountRecord::mutable_groups() {
  // @@protoc_insertion_point(field_mutable_list:keeptower.AccountRecord.groups)
  return &groups_;
}
inline const ::keeptower::GroupMembership& AccountRecord::_internal_groups(int index) const {
  return groups_.Get(index);
}
inline const ::keeptower::GroupMembership& AccountRecord::groups(int index) const {
  // @@protoc_insertion_point(field_get:keeptower.AccountRecord.groups)
  return _internal_groups(index);
}
inline ::keeptower::GroupMembership* AccountRecord::_internal_add_groups() {
  return groups_.Add();
}
inline ::keeptower::GroupMembership* AccountRecord::add_groups() {
  ::keeptower::GroupMembership* _add = _internal_add_groups();
  // @@protoc_insertion_point(field_add:keeptower.AccountRecord.groups)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::keeptower::GroupMembership >&
AccountRecord::groups() const {
  // @@protoc_insertion_point(field_list:keeptower.AccountRecord.groups)
  return groups_;
}

// -------------------------------------------------------------------

// VaultMetadata

// int32 schema_version = 1;
inline void VaultMetadata::clear_schema_version() {
  schema_version_ = 0;
}
inline int32_t VaultMetadata::_internal_schema_version() const {
  return schema_version_;
}
inline int32_t VaultMetadata::schema_version() const {
  // @@protoc_insertion_point(field_get:keeptower.VaultMetadata.schema_version)
  return _internal_schema_version();
}
inline void VaultMetadata::_internal_set_schema_version(int32_t value) {
  
  schema_version_ = value;
}
inline void VaultMetadata::set_schema_version(int32_t value) {
  _internal_set_schema_version(value);
  // @@protoc_insertion_point(field_set:keeptower.VaultMetadata.schema_version)
}

// int64 created_at = 2;
inline void VaultMetadata::clear_created_at() {
  created_at_ = int64_t{0};
}
inline int64_t VaultMetadata::_internal_created_at() const {
  return created_at_;
}
inline int64_t VaultMetadata::created_at() const {
  // @@protoc_insertion_point(field_get:keeptower.VaultMetadata.created_at)
  return _internal_created_at();
}
inline void VaultMetadata::_internal_set_created_at(int64_t value) {
  
  created_at_ = value;
}
inline void VaultMetadata::set_created_at(int64_t value) {
  _internal_set_created_at(value);
  // @@protoc_insertion_point(field_set:keeptower.VaultMetadata.created_at)
}

// int64 last_modified = 3;
inline void VaultMetadata::clear_last_modified() {
  last_modified_ = int64_t{0};
}
inline int64_t VaultMetadata::_internal_last_modified() const {
  return last_modified_;
}
inline int64_t VaultMetadata::last_modified() const {
  // @@protoc_insertion_point(field_get:keeptower.VaultMetadata.last_modified)
  return _internal_last_modified();
}
inline void VaultMetadata::_internal_set_last_modified(int64_t value) {
  
  last_modified_ = value;
}
inline void VaultMetadata::set_last_modified(int64_t value) {
  _internal_set_last_modified(value);
  // @@protoc_insertion_point(field_set:keeptower.VaultMetadata.last_modified)
}

// int64 last_accessed = 4;
inline void VaultMetadata::clear_last_accessed() {
  last_accessed_ = int64_t{0};
}
inline int64_t VaultMetadata::_internal_last_accessed() const {
  return last_accessed_;
}
inline int64_t VaultMetadata::last_accessed() const {
  // @@protoc_insertion_point(field_get:keeptower.VaultMetadata.last_accessed)
  return _internal_last_accessed();
}
inline void VaultMetadata::_internal_set_last_accessed(int64_t value) {
  
  last_accessed_ = value;
}
inline void VaultMetadata::set_last_accessed(int64_t value) {
  _internal_set_last_accessed(value);
  // @@protoc_insertion_point(field_set:keeptower.VaultMetadata.last_accessed)
}

// string name = 5;
inline void VaultMetadata::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& VaultMetadata::name() const {
  // @@protoc_insertion_point(field_get:keeptower.VaultMetadata.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VaultMetadata::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:keeptower.VaultMetadata.name)
}
inline std::string* VaultMetadata::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:keeptower.VaultMetadata.name)
  return _s;
}
inline const std::string& VaultMetadata::_internal_name() const {
  return name_.Get();
}
inline void VaultMetadata::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* VaultMetadata::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* VaultMetadata::release_name() {
  // @@protoc_insertion_point(field_release:keeptower.VaultMetadata.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void VaultMetadata::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:keeptower.VaultMetadata.name)
}

// string description = 6;
inline void VaultMetadata::clear_description() {
  description_.ClearToEmpty();
}
inline const std::string& VaultMetadata::description() const {
  // @@protoc_insertion_point(field_get:keeptower.VaultMetadata.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VaultMetadata::set_description(ArgT0&& arg0, ArgT... args) {
 
 description_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:keeptower.VaultMetadata.description)
}
inline std::string* VaultMetadata::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:keeptower.VaultMetadata.description)
  return _s;
}
inline const std::string& VaultMetadata::_internal_description() const {
  return description_.Get();
}
inline void VaultMetadata::_internal_set_description(const std::string& value) {
  
  description_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* VaultMetadata::_internal_mutable_description() {
  
  return description_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* VaultMetadata::release_description() {
  // @@protoc_insertion_point(field_release:keeptower.VaultMetadata.description)
  return description_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void VaultMetadata::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    
  } else {
    
  }
  description_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), description,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (description_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    description_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:keeptower.VaultMetadata.description)
}

// int64 access_count = 7;
inline void VaultMetadata::clear_access_count() {
  access_count_ = int64_t{0};
}
inline int64_t VaultMetadata::_internal_access_count() const {
  return access_count_;
}
inline int64_t VaultMetadata::access_count() const {
  // @@protoc_insertion_point(field_get:keeptower.VaultMetadata.access_count)
  return _internal_access_count();
}
inline void VaultMetadata::_internal_set_access_count(int64_t value) {
  
  access_count_ = value;
}
inline void VaultMetadata::set_access_count(int64_t value) {
  _internal_set_access_count(value);
  // @@protoc_insertion_point(field_set:keeptower.VaultMetadata.access_count)
}

// -------------------------------------------------------------------

// YubiKeyEntry

// string serial = 1;
inline void YubiKeyEntry::clear_serial() {
  serial_.ClearToEmpty();
}
inline const std::string& YubiKeyEntry::serial() const {
  // @@protoc_insertion_point(field_get:keeptower.YubiKeyEntry.serial)
  return _internal_serial();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void YubiKeyEntry::set_serial(ArgT0&& arg0, ArgT... args) {
 
 serial_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:keeptower.YubiKeyEntry.serial)
}
inline std::string* YubiKeyEntry::mutable_serial() {
  std::string* _s = _internal_mutable_serial();
  // @@protoc_insertion_point(field_mutable:keeptower.YubiKeyEntry.serial)
  return _s;
}
inline const std::string& YubiKeyEntry::_internal_serial() const {
  return serial_.Get();
}
inline void YubiKeyEntry::_internal_set_serial(const std::string& value) {
  
  serial_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* YubiKeyEntry::_internal_mutable_serial() {
  
  return serial_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* YubiKeyEntry::release_serial() {
  // @@protoc_insertion_point(field_release:keeptower.YubiKeyEntry.serial)
  return serial_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void YubiKeyEntry::set_allocated_serial(std::string* serial) {
  if (serial != nullptr) {
    
  } else {
    
  }
  serial_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), serial,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (serial_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    serial_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:keeptower.YubiKeyEntry.serial)
}

// string name = 2;
inline void YubiKeyEntry::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& YubiKeyEntry::name() const {
  // @@protoc_insertion_point(field_get:keeptower.YubiKeyEntry.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void YubiKeyEntry::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:keeptower.YubiKeyEntry.name)
}
inline std::string* YubiKeyEntry::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:keeptower.YubiKeyEntry.name)
  return _s;
}
inline const std::string& YubiKeyEntry::_internal_name() const {
  return name_.Get();
}
inline void YubiKeyEntry::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* YubiKeyEntry::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* YubiKeyEntry::release_name() {
  // @@protoc_insertion_point(field_release:keeptower.YubiKeyEntry.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void YubiKeyEntry::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:keeptower.YubiKeyEntry.name)
}

// int64 added_at = 3;
inline void YubiKeyEntry::clear_added_at() {
  added_at_ = int64_t{0};
}
inline int64_t YubiKeyEntry::_internal_added_at() const {
  return added_at_;
}
inline int64_t YubiKeyEntry::added_at() const {
  // @@protoc_insertion_point(field_get:keeptower.YubiKeyEntry.added_at)
  return _internal_added_at();
}
inline void YubiKeyEntry::_internal_set_added_at(int64_t value) {
  
  added_at_ = value;
}
inline void YubiKeyEntry::set_added_at(int64_t value) {
  _internal_set_added_at(value);
  // @@protoc_insertion_point(field_set:keeptower.YubiKeyEntry.added_at)
}

// -------------------------------------------------------------------

// YubiKeyConfig

// string serial = 1 [deprecated = true];
inline void YubiKeyConfig::clear_serial() {
  serial_.ClearToEmpty();
}
inline const std::string& YubiKeyConfig::serial() const {
  // @@protoc_insertion_point(field_get:keeptower.YubiKeyConfig.serial)
  return _internal_serial();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void YubiKeyConfig::set_serial(ArgT0&& arg0, ArgT... args) {
 
 serial_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:keeptower.YubiKeyConfig.serial)
}
inline std::string* YubiKeyConfig::mutable_serial() {
  std::string* _s = _internal_mutable_serial();
  // @@protoc_insertion_point(field_mutable:keeptower.YubiKeyConfig.serial)
  return _s;
}
inline const std::string& YubiKeyConfig::_internal_serial() const {
  return serial_.Get();
}
inline void YubiKeyConfig::_internal_set_serial(const std::string& value) {
  
  serial_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* YubiKeyConfig::_internal_mutable_serial() {
  
  return serial_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* YubiKeyConfig::release_serial() {
  // @@protoc_insertion_point(field_release:keeptower.YubiKeyConfig.serial)
  return serial_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void YubiKeyConfig::set_allocated_serial(std::string* serial) {
  if (serial != nullptr) {
    
  } else {
    
  }
  serial_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), serial,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (serial_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    serial_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:keeptower.YubiKeyConfig.serial)
}

// bytes challenge = 2;
inline void YubiKeyConfig::clear_challenge() {
  challenge_.ClearToEmpty();
}
inline const std::string& YubiKeyConfig::challenge() const {
  // @@protoc_insertion_point(field_get:keeptower.YubiKeyConfig.challenge)
  return _internal_challenge();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void YubiKeyConfig::set_challenge(ArgT0&& arg0, ArgT... args) {
 
 challenge_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:keeptower.YubiKeyConfig.challenge)
}
inline std::string* YubiKeyConfig::mutable_challenge() {
  std::string* _s = _internal_mutable_challenge();
  // @@protoc_insertion_point(field_mutable:keeptower.YubiKeyConfig.challenge)
  return _s;
}
inline const std::string& YubiKeyConfig::_internal_challenge() const {
  return challenge_.Get();
}
inline void YubiKeyConfig::_internal_set_challenge(const std::string& value) {
  
  challenge_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* YubiKeyConfig::_internal_mutable_challenge() {
  
  return challenge_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* YubiKeyConfig::release_challenge() {
  // @@protoc_insertion_point(field_release:keeptower.YubiKeyConfig.challenge)
  return challenge_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void YubiKeyConfig::set_allocated_challenge(std::string* challenge) {
  if (challenge != nullptr) {
    
  } else {
    
  }
  challenge_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), challenge,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (challenge_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    challenge_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:keeptower.YubiKeyConfig.challenge)
}

// int64 configured_at = 3;
inline void YubiKeyConfig::clear_configured_at() {
  configured_at_ = int64_t{0};
}
inline int64_t YubiKeyConfig::_internal_configured_at() const {
  return configured_at_;
}
inline int64_t YubiKeyConfig::configured_at() const {
  // @@protoc_insertion_point(field_get:keeptower.YubiKeyConfig.configured_at)
  return _internal_configured_at();
}
inline void YubiKeyConfig::_internal_set_configured_at(int64_t value) {
  
  configured_at_ = value;
}
inline void YubiKeyConfig::set_configured_at(int64_t value) {
  _internal_set_configured_at(value);
  // @@protoc_insertion_point(field_set:keeptower.YubiKeyConfig.configured_at)
}

// bool required = 4;
inline void YubiKeyConfig::clear_required() {
  required_ = false;
}
inline bool YubiKeyConfig::_internal_required() const {
  return required_;
}
inline bool YubiKeyConfig::required() const {
  // @@protoc_insertion_point(field_get:keeptower.YubiKeyConfig.required)
  return _internal_required();
}
inline void YubiKeyConfig::_internal_set_required(bool value) {
  
  required_ = value;
}
inline void YubiKeyConfig::set_required(bool value) {
  _internal_set_required(value);
  // @@protoc_insertion_point(field_set:keeptower.YubiKeyConfig.required)
}

// repeated .keeptower.YubiKeyEntry yubikey_entries = 5;
inline int YubiKeyConfig::_internal_yubikey_entries_size() const {
  return yubikey_entries_.size();
}
inline int YubiKeyConfig::yubikey_entries_size() const {
  return _internal_yubikey_entries_size();
}
inline void YubiKeyConfig::clear_yubikey_entries() {
  yubikey_entries_.Clear();
}
inline ::keeptower::YubiKeyEntry* YubiKeyConfig::mutable_yubikey_entries(int index) {
  // @@protoc_insertion_point(field_mutable:keeptower.YubiKeyConfig.yubikey_entries)
  return yubikey_entries_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::keeptower::YubiKeyEntry >*
YubiKeyConfig::mutable_yubikey_entries() {
  // @@protoc_insertion_point(field_mutable_list:keeptower.YubiKeyConfig.yubikey_entries)
  return &yubikey_entries_;
}
inline const ::keeptower::YubiKeyEntry& YubiKeyConfig::_internal_yubikey_entries(int index) const {
  return yubikey_entries_.Get(index);
}
inline const ::keeptower::YubiKeyEntry& YubiKeyConfig::yubikey_entries(int index) const {
  // @@protoc_insertion_point(field_get:keeptower.YubiKeyConfig.yubikey_entries)
  return _internal_yubikey_entries(index);
}
inline ::keeptower::YubiKeyEntry* YubiKeyConfig::_internal_add_yubikey_entries() {
  return yubikey_entries_.Add();
}
inline ::keeptower::YubiKeyEntry* YubiKeyConfig::add_yubikey_entries() {
  ::keeptower::YubiKeyEntry* _add = _internal_add_yubikey_entries();
  // @@protoc_insertion_point(field_add:keeptower.YubiKeyConfig.yubikey_entries)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::keeptower::YubiKeyEntry >&
YubiKeyConfig::yubikey_entries() const {
  // @@protoc_insertion_point(field_list:keeptower.YubiKeyConfig.yubikey_entries)
  return yubikey_entries_;
}

// -------------------------------------------------------------------

// VaultData

// repeated .keeptower.AccountRecord accounts = 1;
inline int VaultData::_internal_accounts_size() const {
  return accounts_.size();
}
inline int VaultData::accounts_size() const {
  return _internal_accounts_size();
}
inline void VaultData::clear_accounts() {
  accounts_.Clear();
}
inline ::keeptower::AccountRecord* VaultData::mutable_accounts(int index) {
  // @@protoc_insertion_point(field_mutable:keeptower.VaultData.accounts)
  return accounts_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::keeptower::AccountRecord >*
VaultData::mutable_accounts() {
  // @@protoc_insertion_point(field_mutable_list:keeptower.VaultData.accounts)
  return &accounts_;
}
inline const ::keeptower::AccountRecord& VaultData::_internal_accounts(int index) const {
  return accounts_.Get(index);
}
inline const ::keeptower::AccountRecord& VaultData::accounts(int index) const {
  // @@protoc_insertion_point(field_get:keeptower.VaultData.accounts)
  return _internal_accounts(index);
}
inline ::keeptower::AccountRecord* VaultData::_internal_add_accounts() {
  return accounts_.Add();
}
inline ::keeptower::AccountRecord* VaultData::add_accounts() {
  ::keeptower::AccountRecord* _add = _internal_add_accounts();
  // @@protoc_insertion_point(field_add:keeptower.VaultData.accounts)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::keeptower::AccountRecord >&
VaultData::accounts() const {
  // @@protoc_insertion_point(field_list:keeptower.VaultData.accounts)
  return accounts_;
}

// .keeptower.VaultMetadata metadata = 2;
inline bool VaultData::_internal_has_metadata() const {
  return this != internal_default_instance() && metadata_ != nullptr;
}
inline bool VaultData::has_metadata() const {
  return _internal_has_metadata();
}
inline void VaultData::clear_metadata() {
  if (GetArenaForAllocation() == nullptr && metadata_ != nullptr) {
    delete metadata_;
  }
  metadata_ = nullptr;
}
inline const ::keeptower::VaultMetadata& VaultData::_internal_metadata() const {
  const ::keeptower::VaultMetadata* p = metadata_;
  return p != nullptr ? *p : reinterpret_cast<const ::keeptower::VaultMetadata&>(
      ::keeptower::_VaultMetadata_default_instance_);
}
inline const ::keeptower::VaultMetadata& VaultData::metadata() const {
  // @@protoc_insertion_point(field_get:keeptower.VaultData.metadata)
  return _internal_metadata();
}
inline void VaultData::unsafe_arena_set_allocated_metadata(
    ::keeptower::VaultMetadata* metadata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(metadata_);
  }
  metadata_ = metadata;
  if (metadata) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:keeptower.VaultData.metadata)
}
inline ::keeptower::VaultMetadata* VaultData::release_metadata() {
  
  ::keeptower::VaultMetadata* temp = metadata_;
  metadata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::keeptower::VaultMetadata* VaultData::unsafe_arena_release_metadata() {
  // @@protoc_insertion_point(field_release:keeptower.VaultData.metadata)
  
  ::keeptower::VaultMetadata* temp = metadata_;
  metadata_ = nullptr;
  return temp;
}
inline ::keeptower::VaultMetadata* VaultData::_internal_mutable_metadata() {
  
  if (metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::keeptower::VaultMetadata>(GetArenaForAllocation());
    metadata_ = p;
  }
  return metadata_;
}
inline ::keeptower::VaultMetadata* VaultData::mutable_metadata() {
  ::keeptower::VaultMetadata* _msg = _internal_mutable_metadata();
  // @@protoc_insertion_point(field_mutable:keeptower.VaultData.metadata)
  return _msg;
}
inline void VaultData::set_allocated_metadata(::keeptower::VaultMetadata* metadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete metadata_;
  }
  if (metadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::keeptower::VaultMetadata>::GetOwningArena(metadata);
    if (message_arena != submessage_arena) {
      metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, metadata, submessage_arena);
    }
    
  } else {
    
  }
  metadata_ = metadata;
  // @@protoc_insertion_point(field_set_allocated:keeptower.VaultData.metadata)
}

// .keeptower.YubiKeyConfig yubikey_config = 16;
inline bool VaultData::_internal_has_yubikey_config() const {
  return this != internal_default_instance() && yubikey_config_ != nullptr;
}
inline bool VaultData::has_yubikey_config() const {
  return _internal_has_yubikey_config();
}
inline void VaultData::clear_yubikey_config() {
  if (GetArenaForAllocation() == nullptr && yubikey_config_ != nullptr) {
    delete yubikey_config_;
  }
  yubikey_config_ = nullptr;
}
inline const ::keeptower::YubiKeyConfig& VaultData::_internal_yubikey_config() const {
  const ::keeptower::YubiKeyConfig* p = yubikey_config_;
  return p != nullptr ? *p : reinterpret_cast<const ::keeptower::YubiKeyConfig&>(
      ::keeptower::_YubiKeyConfig_default_instance_);
}
inline const ::keeptower::YubiKeyConfig& VaultData::yubikey_config() const {
  // @@protoc_insertion_point(field_get:keeptower.VaultData.yubikey_config)
  return _internal_yubikey_config();
}
inline void VaultData::unsafe_arena_set_allocated_yubikey_config(
    ::keeptower::YubiKeyConfig* yubikey_config) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(yubikey_config_);
  }
  yubikey_config_ = yubikey_config;
  if (yubikey_config) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:keeptower.VaultData.yubikey_config)
}
inline ::keeptower::YubiKeyConfig* VaultData::release_yubikey_config() {
  
  ::keeptower::YubiKeyConfig* temp = yubikey_config_;
  yubikey_config_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::keeptower::YubiKeyConfig* VaultData::unsafe_arena_release_yubikey_config() {
  // @@protoc_insertion_point(field_release:keeptower.VaultData.yubikey_config)
  
  ::keeptower::YubiKeyConfig* temp = yubikey_config_;
  yubikey_config_ = nullptr;
  return temp;
}
inline ::keeptower::YubiKeyConfig* VaultData::_internal_mutable_yubikey_config() {
  
  if (yubikey_config_ == nullptr) {
    auto* p = CreateMaybeMessage<::keeptower::YubiKeyConfig>(GetArenaForAllocation());
    yubikey_config_ = p;
  }
  return yubikey_config_;
}
inline ::keeptower::YubiKeyConfig* VaultData::mutable_yubikey_config() {
  ::keeptower::YubiKeyConfig* _msg = _internal_mutable_yubikey_config();
  // @@protoc_insertion_point(field_mutable:keeptower.VaultData.yubikey_config)
  return _msg;
}
inline void VaultData::set_allocated_yubikey_config(::keeptower::YubiKeyConfig* yubikey_config) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete yubikey_config_;
  }
  if (yubikey_config) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::keeptower::YubiKeyConfig>::GetOwningArena(yubikey_config);
    if (message_arena != submessage_arena) {
      yubikey_config = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, yubikey_config, submessage_arena);
    }
    
  } else {
    
  }
  yubikey_config_ = yubikey_config;
  // @@protoc_insertion_point(field_set_allocated:keeptower.VaultData.yubikey_config)
}

// bool fec_enabled = 17;
inline void VaultData::clear_fec_enabled() {
  fec_enabled_ = false;
}
inline bool VaultData::_internal_fec_enabled() const {
  return fec_enabled_;
}
inline bool VaultData::fec_enabled() const {
  // @@protoc_insertion_point(field_get:keeptower.VaultData.fec_enabled)
  return _internal_fec_enabled();
}
inline void VaultData::_internal_set_fec_enabled(bool value) {
  
  fec_enabled_ = value;
}
inline void VaultData::set_fec_enabled(bool value) {
  _internal_set_fec_enabled(value);
  // @@protoc_insertion_point(field_set:keeptower.VaultData.fec_enabled)
}

// int32 fec_redundancy_percent = 18;
inline void VaultData::clear_fec_redundancy_percent() {
  fec_redundancy_percent_ = 0;
}
inline int32_t VaultData::_internal_fec_redundancy_percent() const {
  return fec_redundancy_percent_;
}
inline int32_t VaultData::fec_redundancy_percent() const {
  // @@protoc_insertion_point(field_get:keeptower.VaultData.fec_redundancy_percent)
  return _internal_fec_redundancy_percent();
}
inline void VaultData::_internal_set_fec_redundancy_percent(int32_t value) {
  
  fec_redundancy_percent_ = value;
}
inline void VaultData::set_fec_redundancy_percent(int32_t value) {
  _internal_set_fec_redundancy_percent(value);
  // @@protoc_insertion_point(field_set:keeptower.VaultData.fec_redundancy_percent)
}

// repeated .keeptower.AccountGroup groups = 32;
inline int VaultData::_internal_groups_size() const {
  return groups_.size();
}
inline int VaultData::groups_size() const {
  return _internal_groups_size();
}
inline void VaultData::clear_groups() {
  groups_.Clear();
}
inline ::keeptower::AccountGroup* VaultData::mutable_groups(int index) {
  // @@protoc_insertion_point(field_mutable:keeptower.VaultData.groups)
  return groups_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::keeptower::AccountGroup >*
VaultData::mutable_groups() {
  // @@protoc_insertion_point(field_mutable_list:keeptower.VaultData.groups)
  return &groups_;
}
inline const ::keeptower::AccountGroup& VaultData::_internal_groups(int index) const {
  return groups_.Get(index);
}
inline const ::keeptower::AccountGroup& VaultData::groups(int index) const {
  // @@protoc_insertion_point(field_get:keeptower.VaultData.groups)
  return _internal_groups(index);
}
inline ::keeptower::AccountGroup* VaultData::_internal_add_groups() {
  return groups_.Add();
}
inline ::keeptower::AccountGroup* VaultData::add_groups() {
  ::keeptower::AccountGroup* _add = _internal_add_groups();
  // @@protoc_insertion_point(field_add:keeptower.VaultData.groups)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::keeptower::AccountGroup >&
VaultData::groups() const {
  // @@protoc_insertion_point(field_list:keeptower.VaultData.groups)
  return groups_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace keeptower

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_src_2frecord_2eproto
